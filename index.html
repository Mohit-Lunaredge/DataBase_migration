<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MySQL to PostgreSQL Migration Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .column-item:hover { background-color: #f0f4f8; }
        .drop-zone { border: 2px dashed #cbd5e1; }
        .drop-zone.drag-over { background-color: #e2e8f0; border-color: #4a5568; }
        .mapped { background-color: #c6f6d5 !important; border-color: #38a169 !important; font-weight: 600; }
        .mapped-target { background-color: #e6fffa !important; border-color: #38b2ac !important; }
        .mapped-line { stroke: #4a5568; stroke-width: 2; marker-end: url(#arrow); }
        .dragging { opacity: 0.5; }
        #mapping-container { position: relative; }
        #mapping-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .table-filter-panel-content { max-height: 200px; overflow-y: auto; }
        .error-details { background-color: #2d3748; color: #e2e8f0; padding: 0.75rem; margin-top: 0.5rem; border-radius: 0.25rem; font-family: 'Courier New', Courier, monospace; font-size: 0.8rem; white-space: pre-wrap; word-break: break-all; }
        .data-type { font-size: 0.75rem; color: #718096; margin-left: 0.5rem; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 50; }
        .modal-content { background: white; padding: 2rem; border-radius: 0.5rem; width: 90vw; max-width: 800px; max-height: 90vh; overflow-y: auto; }
        .mapping-info-badge { font-size: 0.65rem; font-weight: bold; color: #2c5282; background-color: #bee3f8; padding: 2px 4px; border-radius: 4px; margin-left: auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; display: inline-block; vertical-align: middle;}
        .not-null-badge { font-size: 0.65rem; font-weight: bold; color: #c53030; background-color: #fed7d7; padding: 2px 4px; border-radius: 4px; margin-left: 0.5rem; }
        .data-preview-list { max-height: 400px; overflow-y: auto; }
        .data-preview-table { width: 100%; border-collapse: collapse; }
        .data-preview-table th, .data-preview-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .data-preview-table th { background-color: #f2f2f2; }
        .hidden { display: none !important; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">MySQL to PostgreSQL Migration Assistant</h1>
            <p class="text-md text-gray-600 mt-2">Dynamically connect to your database and migrate data.</p>
        </header>
        
        <div id="status-area" class="mb-4 p-4 text-center rounded-md hidden"></div>

        <!-- Saved Mappings Section -->
        <div id="saved-mappings-section" class="bg-white p-6 rounded-lg shadow-md mb-8">
             <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Mappings</h2>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="savedMappingsSelector" class="block text-sm font-medium text-gray-700 mb-1">Load Existing Mapping</label>
                    <div class="flex">
                        <select id="savedMappingsSelector" class="w-full p-2 border rounded-l-md">
                             <option value="">-- Loading mappings... --</option>
                        </select>
                        <button id="loadMappingButton" type="button" class="bg-blue-600 text-white px-4 py-2 rounded-r-md hover:bg-blue-700 transition">Load</button>
                    </div>
                </div>
                <div>
                    <label for="newMappingNameInput" class="block text-sm font-medium text-gray-700 mb-1">Save Current Mapping</label>
                    <div class="flex">
                        <input type="text" id="newMappingNameInput" placeholder="Enter a name for this mapping" class="w-full p-2 border rounded-l-md">
                        <button id="saveMappingButton" type="button" class="bg-green-600 text-white px-4 py-2 rounded-r-md hover:bg-green-700 transition">Save</button>
                    </div>
                </div>
             </div>
        </div>

        <!-- Step 1: Provide MySQL Dump File Path -->
        <div id="step1" class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Step 1: Select MySQL Dump File</h2>
            <p class="text-gray-600 mb-4">Select a file from the `sql_files` directory on the server, or provide a custom path.</p>
            <select id="sqlFileSelector" class="w-full p-2 border rounded-md mb-2">
                <option value="">-- Loading files... --</option>
            </select>
            <input type="text" id="sqlFilePathInput" placeholder="/path/to/your/dump.sql" class="w-full p-2 border rounded-md hidden">
            <button id="parseSqlFileButton" type="button" class="mt-4 bg-blue-600 text-white px-5 py-2 rounded-md hover:bg-blue-700 transition">Parse SQL File</button>
        </div>

        <!-- Step 2: Connect to PostgreSQL -->
        <div id="step2" class="bg-white p-6 rounded-lg shadow-md mb-8 hidden">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Step 2: Connect to PostgreSQL</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <input type="text" id="pgHost" placeholder="Hostname (e.g., localhost)" class="p-2 border rounded-md" value="localhost">
                <input type="number" id="pgPort" value="5432" placeholder="Port" class="p-2 border rounded-md">
                <input type="text" id="pgUser" placeholder="Username" class="p-2 border rounded-md" value="postgres">
                <input type="password" id="pgPassword" placeholder="Password" class="p-2 border rounded-md" value="password">
            </div>
            <button id="fetchDatabasesButton" type="button" class="mt-4 bg-green-600 text-white px-5 py-2 rounded-md hover:bg-green-700 transition">Connect & Fetch Databases</button>
        </div>
        
        <!-- Step 2b: Select Database -->
        <div id="step2b-db-select" class="bg-white p-6 rounded-lg shadow-md mb-8 hidden">
            <h3 class="text-xl font-semibold mb-2">Select Target Database</h3>
            <select id="dbSelector" class="w-full p-2 border rounded-md mb-4"></select>
            <button id="fetchTablesButton" type="button" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition">Fetch Tables for Selected DB</button>
        </div>

        <!-- Step 3: Mapping Interface -->
        <div id="step3" class="hidden">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Step 3: Map Tables and Columns</h2>
            <div id="mapping-container">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-semibold mb-4 text-blue-800">Source (MySQL)</h3>
                        <div id="mysql-table-filter" class="mb-4"></div>
                        <div id="mysqlSchema" class="space-y-4"></div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-semibold mb-4 text-green-800">Target (PostgreSQL)</h3>
                        <div id="pg-table-filter" class="mb-4"></div>
                        <div id="postgresSchema" class="space-y-4"></div>
                    </div>
                </div>
                <svg id="mapping-svg">
                    <defs>
                        <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                            <path d="M 0 0 L 10 5 L 0 10 z" fill="#4a5568" />
                        </marker>
                    </defs>
                </svg>
            </div>
        </div>

        <!-- Custom Commands Section -->
        <div id="step3b-custom-commands" class="hidden bg-white p-6 rounded-lg shadow-md my-8">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Custom SQL Commands (Optional)</h2>
            <p class="text-gray-600 mb-4">Enter SQL commands to run on the target database before or after the migration. Separate multiple commands with a semicolon (;).</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="pre-migration-commands" class="block text-sm font-medium text-gray-700 mb-1">Pre-Migration Commands</label>
                    <textarea id="pre-migration-commands" rows="4" class="w-full p-2 border rounded-md font-mono text-sm" placeholder="e.g., CREATE EXTENSION IF NOT EXISTS &quot;uuid-ossp&quot;;"></textarea>
                </div>
                <div>
                    <label for="post-migration-commands" class="block text-sm font-medium text-gray-700 mb-1">Post-Migration Commands</label>
                    <textarea id="post-migration-commands" rows="4" class="w-full p-2 border rounded-md font-mono text-sm" placeholder="e.g., CREATE INDEX idx_users_email ON users(email);"></textarea>
                </div>
            </div>
        </div>

        <!-- Step 4: Run Migration -->
        <div id="step4" class="hidden mt-8 text-center">
            <div class="space-y-2">
                <label class="flex items-center justify-center">
                    <input type="checkbox" id="truncateCheckbox" class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500">
                    <span class="ml-2 text-gray-700">Clear target tables before migrating (TRUNCATE)</span>
                </label>
                <label class="flex items-center justify-center">
                    <input type="checkbox" id="upsertCheckbox" class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500">
                    <span class="ml-2 text-gray-700">Update existing records on conflict (Upsert on 'id' column)</span>
                </label>
            </div>
            <button id="runMigrationButton" type="button" class="mt-4 bg-purple-600 text-white font-bold px-8 py-3 rounded-lg hover:bg-purple-700 transition shadow-lg">RUN MIGRATION</button>
        </div>

    </div>
    
    <!-- Modals -->
    <div id="settings-modal" class="modal-overlay hidden">
        <div id="settings-modal-content" class="modal-content"></div>
    </div>
    <div id="mapping-panel-modal" class="modal-overlay hidden">
        <div id="mapping-panel-content" class="modal-content"></div>
    </div>
    <div id="data-preview-modal" class="modal-overlay hidden">
        <div id="data-preview-content" class="modal-content"></div>
    </div>

    <script>
        // Global state variables
        let mysqlSchemaData = {};
        let postgresSchemaData = {};
        let pgConnectionDetails = {};
        let mappingRules = {};
        let migrationFilters = {};
        const API_BASE_URL = "http://127.0.0.1:5000";

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeStep1();

            // Attach event listeners to buttons
            document.getElementById('parseSqlFileButton').addEventListener('click', parseSqlFileOnServer);
            document.getElementById('fetchDatabasesButton').addEventListener('click', fetchDatabases);
            document.getElementById('fetchTablesButton').addEventListener('click', fetchTables);
            document.getElementById('runMigrationButton').addEventListener('click', runMigration);
            document.getElementById('loadMappingButton').addEventListener('click', loadSelectedMapping);
            document.getElementById('saveMappingButton').addEventListener('click', saveCurrentMapping);
        });

        async function initializeStep1() {
            const selector = document.getElementById('sqlFileSelector');
            try {
                const response = await fetch(`${API_BASE_URL}/api/list_sql_files`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const files = await response.json();
                selector.innerHTML = '<option value="">-- Select a file --</option>';
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.textContent = file;
                    selector.appendChild(option);
                });
            } catch (error) {
                handleFetchError(error, "loading SQL file list");
                selector.innerHTML = '<option value="">-- Could not load files --</option>';
            }
            selector.innerHTML += '<option value="custom">-- Enter Full Path Manually --</option>';
            selector.onchange = () => {
                const customPathInput = document.getElementById('sqlFilePathInput');
                customPathInput.classList.toggle('hidden', selector.value !== 'custom');
            };
            loadSavedMappings(); 
        }

        // --- Status Update Function ---
        function showStatus(message, isError = false) {
            const statusArea = document.getElementById('status-area');
            statusArea.innerHTML = message;
            statusArea.className = 'mb-4 p-4 text-center rounded-md';
            statusArea.classList.add(isError ? 'bg-red-100' : 'bg-blue-100', isError ? 'text-red-700' : 'text-blue-700');
            statusArea.classList.remove('hidden');
        }

        function handleFetchError(error, context) {
            let errorMessage = `Error during ${context}: ${error.message}.`;
            if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                errorMessage += ' <b>Could not connect to the backend server.</b> Please ensure the app.py server is running in your terminal.';
            }
            showStatus(errorMessage, true);
        }

        // --- API Calls ---
        async function parseSqlFileOnServer() {
            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let payload = {};
            if (selector.value === 'custom') {
                if (!customPathInput.value) { alert("Please enter a custom file path."); return; }
                payload = { path: customPathInput.value };
            } else if (selector.value) {
                payload = { filename: selector.value };
            } else {
                alert("Please select a SQL file.");
                return;
            }
            showStatus("Parsing SQL file on server...", false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/parse_sql_file`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to parse file.');
                mysqlSchemaData = data;
                displayMysqlSchema();
                showStatus("SQL file parsed successfully. Please connect to PostgreSQL.", false);
                document.getElementById('step2').classList.remove('hidden');
            } catch (error) {
                handleFetchError(error, "parsing SQL file");
            }
        }

        async function fetchDatabases() {
            pgConnectionDetails = {
                host: document.getElementById('pgHost').value,
                port: document.getElementById('pgPort').value,
                user: document.getElementById('pgUser').value,
                password: document.getElementById('pgPassword').value
            };
            showStatus("Connecting to PostgreSQL...", false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/get_databases`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pgConnectionDetails)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to connect.');
                const selector = document.getElementById('dbSelector');
                selector.innerHTML = '';
                data.forEach(dbName => {
                    const option = document.createElement('option');
                    option.value = dbName;
                    option.textContent = dbName;
                    selector.appendChild(option);
                });
                showStatus("Successfully fetched databases. Please select one.", false);
                document.getElementById('step2b-db-select').classList.remove('hidden');
            } catch (error) {
                handleFetchError(error, "fetching databases");
            }
        }

        async function fetchTables() {
            const selectedDb = document.getElementById('dbSelector').value;
            if (!selectedDb) { alert("Please select a database first."); return; }
            pgConnectionDetails.dbname = selectedDb;
            showStatus(`Fetching tables from "${selectedDb}"...`, false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/get_tables`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ creds: pgConnectionDetails, dbname: selectedDb })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to fetch tables.');
                postgresSchemaData = data;
                displayPostgresSchema();
                showStatus("Successfully fetched tables. You may now map the columns.", false);
                document.getElementById('step3').classList.remove('hidden');
                document.getElementById('step3b-custom-commands').classList.remove('hidden');
                document.getElementById('step4').classList.remove('hidden');
            } catch(error) {
                handleFetchError(error, "fetching tables");
            }
        }

        async function runMigration() {
            if (Object.keys(mappingRules).length === 0) {
                alert("Please define at least one mapping rule before running the migration.");
                return;
            }
            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let filePath = selector.value === 'custom' ? customPathInput.value : selector.value;
            const migrationConfig = {
                pg_config: pgConnectionDetails,
                mapping_rules: mappingRules,
                mysql_dump_file_path: filePath,
                truncate_tables: document.getElementById('truncateCheckbox').checked,
                handle_conflicts: document.getElementById('upsertCheckbox').checked,
                filters: migrationFilters,
                pre_migration_commands: document.getElementById('pre-migration-commands').value,
                post_migration_commands: document.getElementById('post-migration-commands').value
            };
            showStatus("Migration started... This may take a while.", false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/run_migration`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(migrationConfig)
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || "An unknown server error occurred.");
                let summaryHtml = `<h3 class="text-lg font-semibold mb-2">${result.message}</h3>`;
                summaryHtml += '<div class="text-left max-w-3xl mx-auto border rounded-lg bg-white">';
                if (Object.keys(result.summary).length === 0) {
                    summaryHtml += '<p class="p-4">No data was processed. Check if the source tables exist in the SQL file and are mapped correctly.</p>';
                }
                for (const table in result.summary) {
                    const stats = result.summary[table];
                    summaryHtml += `<div class="p-3 border-b last:border-b-0">`;
                    summaryHtml += `<p><strong>Table: ${table}</strong></p>`;
                    summaryHtml += `<p class="text-green-700">Rows Inserted: ${stats.inserted || 0}</p>`;
                    if (stats.updated > 0) {
                        summaryHtml += `<p class="text-blue-700">Rows Updated (Upsert): ${stats.updated}</p>`;
                    }
                    if (stats.filtered_out > 0) {
                        summaryHtml += `<p class="text-yellow-600">Rows Filtered Out (by WHERE clause): ${stats.filtered_out}</p>`;
                    }
                    if (stats.failed > 0) {
                        summaryHtml += `<p class="text-red-700">Rows Failed: ${stats.failed}</p>`;
                        if (stats.errors && stats.errors.length > 0) {
                            summaryHtml += `<button onclick="toggleErrorDetails('${table}-errors')" class="text-sm text-blue-600 hover:underline mt-1">Show Errors</button>`;
                            summaryHtml += `<div id="${table}-errors" class="hidden error-details">`;
                            stats.errors.forEach(err => {
                                summaryHtml += `<div><strong>Error:</strong> ${escapeHtml(err.error)}</div>`;
                                summaryHtml += `<div class="mt-1"><strong>Query:</strong> <pre>${escapeHtml(err.query)}</pre></div>`;
                                summaryHtml += `<div class="mt-1"><strong>Values:</strong> ${escapeHtml(JSON.stringify(err.values))}</div><hr class="my-2 border-gray-600">`;
                            });
                            summaryHtml += `</div>`;
                        }
                    }
                    summaryHtml += `</div>`;
                }
                summaryHtml += '</div>';

                const statusArea = document.getElementById('status-area');
                statusArea.innerHTML = summaryHtml;
                statusArea.className = 'mb-4 p-4 rounded-md bg-gray-100';
                statusArea.classList.remove('hidden');
            } catch (error) {
                handleFetchError(error, "running migration");
            }
        }

        function toggleErrorDetails(elementId) {
            document.getElementById(elementId).classList.toggle('hidden');
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe === null || unsafe === undefined ? '' : String(unsafe);
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // --- UI Rendering & Filters ---
        function displayMysqlSchema() {
            const container = document.getElementById('mysqlSchema');
            container.innerHTML = '';
            createTableFilter('mysql-table-filter', mysqlSchemaData, updateSourceTableVisibility);
            for (const tableName in mysqlSchemaData) {
                const tableEl = createSchemaTableElement(tableName, mysqlSchemaData[tableName].columns, 'mysql');
                tableEl.style.display = 'block'; // Show tables by default
                container.appendChild(tableEl);
            }
        }

        function displayPostgresSchema() {
            const container = document.getElementById('postgresSchema');
            container.innerHTML = '';
            createTableFilter('pg-table-filter', postgresSchemaData, updateTargetTableVisibility);
            for (const tableName in postgresSchemaData) {
                const tableEl = createSchemaTableElement(tableName, postgresSchemaData[tableName].columns, 'pg');
                tableEl.style.display = 'block'; // Show tables by default
                container.appendChild(tableEl);
            }
        }

        function createTableFilter(containerId, tables, changeHandler) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            if (Object.keys(tables).length === 0) return;
            const dropdownContainer = document.createElement('div');
            dropdownContainer.className = 'relative';
            const dropdownButton = document.createElement('button');
            dropdownButton.type = 'button';
            dropdownButton.className = 'w-full text-left p-2 border rounded-md bg-white flex justify-between items-center';
            dropdownButton.innerHTML = '<span>Select tables to display...</span><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>';
            const dropdownPanel = document.createElement('div');
            dropdownPanel.className = 'hidden absolute bg-white border mt-1 rounded-md shadow-lg z-20 w-full';
            const searchContainer = document.createElement('div');
            searchContainer.className = 'p-2 border-b';
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'Search tables...';
            searchInput.className = 'w-full p-1 border rounded-md text-sm';
            searchContainer.appendChild(searchInput);
            dropdownPanel.appendChild(searchContainer);
            const listContainer = document.createElement('div');
            listContainer.className = 'table-filter-panel-content';
            Object.keys(tables).sort().forEach(tableName => {
                const label = document.createElement('label');
                label.className = 'flex items-center p-2 hover:bg-gray-100 cursor-pointer text-sm';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'mr-2';
                checkbox.value = tableName;
                checkbox.checked = false; 
                checkbox.addEventListener('change', changeHandler);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(tableName));
                listContainer.appendChild(label);
            });
            dropdownPanel.appendChild(listContainer);
            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.toLowerCase();
                listContainer.querySelectorAll('label').forEach(label => {
                    const tableName = label.textContent.toLowerCase();
                    label.style.display = tableName.includes(searchTerm) ? 'flex' : 'none';
                });
            });
            dropdownButton.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdownPanel.classList.toggle('hidden');
            });
            document.body.addEventListener('click', () => dropdownPanel.classList.add('hidden'));
            dropdownPanel.addEventListener('click', (e) => e.stopPropagation());
            dropdownContainer.appendChild(dropdownButton);
            dropdownContainer.appendChild(dropdownPanel);
            container.appendChild(dropdownContainer);
        }

        function updateSourceTableVisibility() {
            const filterContainer = document.getElementById('mysql-table-filter');
            const checkboxes = filterContainer.querySelectorAll('input[type="checkbox"]');
            const selectedTables = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            for (const tableName in mysqlSchemaData) {
                const tableEl = document.getElementById(`mysql-table-${tableName}`);
                if (tableEl) tableEl.style.display = selectedTables.includes(tableName) ? 'block' : 'none';
            }
            drawMappingLines();
        }

        function updateTargetTableVisibility() {
            const filterContainer = document.getElementById('pg-table-filter');
            const checkboxes = filterContainer.querySelectorAll('input[type="checkbox"]');
            const selectedTables = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            for (const tableName in postgresSchemaData) {
                const tableEl = document.getElementById(`pg-table-${tableName}`);
                if (tableEl) tableEl.style.display = selectedTables.includes(tableName) ? 'block' : 'none';
            }
            drawMappingLines();
        }

        function createSchemaTableElement(tableName, columns, type) {
            const tableDiv = document.createElement('div');
            tableDiv.id = `${type}-table-${tableName}`;
            tableDiv.className = 'p-4 border rounded-lg';
            tableDiv.style.display = 'none';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center';
            headerDiv.innerHTML = `<h4 class="font-bold text-lg">${tableName}</h4>`;

            if (type === 'mysql') {
                const btnGroup = document.createElement('div');
                btnGroup.className = 'flex items-center space-x-2';
                
                const viewBtn = document.createElement('button');
                viewBtn.type = 'button';
                viewBtn.innerHTML = `<svg class="w-5 h-5 text-gray-500 hover:text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>`;
                viewBtn.onclick = () => viewSourceTable(tableName);
                viewBtn.title = "View Full Table Data";
                btnGroup.appendChild(viewBtn);

                const settingsBtn = document.createElement('button');
                settingsBtn.type = 'button';
                settingsBtn.innerHTML = `<svg class="w-5 h-5 text-gray-500 hover:text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>`;
                settingsBtn.onclick = () => openSettingsModal(tableName);
                settingsBtn.title = "Table Settings (Sort, Filter, Replace)";
                btnGroup.appendChild(settingsBtn);

                headerDiv.appendChild(btnGroup);
            }
            tableDiv.appendChild(headerDiv);

            const colsList = document.createElement('div');
            colsList.className = 'mt-2 space-y-2';
            columns.forEach(col => {
                const colItem = document.createElement('div');
                colItem.className = 'column-item p-2 border rounded-md cursor-pointer';
                const mainContent = document.createElement('div');
                mainContent.className = 'flex justify-between items-center';
                const nameAndType = document.createElement('div');
                nameAndType.className = 'flex items-center';

                if (type === 'pg') {
                    colItem.id = `pg-${tableName}-${col.name}`;
                    const nullableBadge = col.is_nullable === 'NO' ? '<span class="not-null-badge">NOT NULL</span>' : '';
                    nameAndType.innerHTML = `<span>${col.name}</span> <span class="data-type">(${col.type})</span>${nullableBadge}`;
                    colItem.dataset.colName = col.name;
                    colItem.dataset.tableName = tableName;
                    colItem.onclick = () => openMappingPanel(tableName, col);
                    colItem.addEventListener('dragover', handleDragOver);
                    colItem.addEventListener('drop', handleDrop);
                } else {
                    colItem.id = `mysql-${tableName}-${col.name}`;
                    nameAndType.innerHTML = `
                        <span>${col.name}</span>
                        <span class="data-type">(${col.type})</span>
                        <button type="button" onclick="event.stopPropagation(); viewColumnData('${tableName}', '${col.name}')" class="ml-2 text-gray-400 hover:text-blue-600" title="Preview Unique Column Values">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                        </button>
                    `;
                    colItem.draggable = true;
                    colItem.addEventListener('dragstart', handleDragStart);
                    colItem.addEventListener('dblclick', handleSourceColumnDoubleClick);
                }

                mainContent.appendChild(nameAndType);
                colItem.appendChild(mainContent);
                colsList.appendChild(colItem);
            });
            tableDiv.appendChild(colsList);
            return tableDiv;
        }

        // --- Drag & Drop ---
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.currentTarget.id);
            e.currentTarget.classList.add('dragging');
        }
        document.addEventListener('dragend', () => document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging')));

        function handleDragOver(e) { e.preventDefault(); }

        function handleDrop(e) {
            e.preventDefault();
            const targetEl = e.target.closest('.column-item[data-col-name]');
            if (!targetEl) return;
            const sourceId = e.dataTransfer.getData('text/plain');
            const [, mysqlTable, mysqlCol] = sourceId.split('-');
            const pgTable = targetEl.dataset.tableName;
            const pgCol = targetEl.dataset.colName;

            if (!mappingRules[pgTable]) mappingRules[pgTable] = {};
            mappingRules[pgTable][pgCol] = { type: 'direct', value: mysqlCol, source_table: mysqlTable };
            
            document.querySelector(`#mysql-table-filter input[value="${mysqlTable}"]`).checked = true;
            document.querySelector(`#pg-table-filter input[value="${pgTable}"]`).checked = true;
            updateSourceTableVisibility();
            updateTargetTableVisibility();

            setTimeout(updateColumnUIs, 50); // Timeout to allow DOM update
        }

        function handleSourceColumnDoubleClick(e) {
            const sourceEl = e.currentTarget;
            if (!sourceEl || !sourceEl.id) return;
            const [, mysqlTable, mysqlCol] = sourceEl.id.split('-');
            if (!mysqlTable || !mysqlCol) return;

            for (const pgTable in mappingRules) {
                for (const pgCol in mappingRules[pgTable]) {
                    const rule = mappingRules[pgTable][pgCol];
                    if ((rule.type === 'direct' && rule.source_table === mysqlTable && rule.value === mysqlCol) ||
                        (rule.type === 'transformation' && rule.source_table === mysqlTable && rule.params.columns.includes(mysqlCol))) {
                        delete mappingRules[pgTable][pgCol];
                    }
                }
                if (Object.keys(mappingRules[pgTable]).length === 0) {
                    delete mappingRules[pgTable];
                }
            }
            updateColumnUIs();
        }

        // --- UI & State Update Helpers ---
        function findSourceTablesForTarget(pgTable) {
            const sourceTables = new Set();
            const rules = mappingRules[pgTable] || {};
            for (const col in rules) {
                const rule = rules[col];
                if (rule.source_table) {
                    sourceTables.add(rule.source_table);
                }
                if (rule.type === 'transformation' && rule.params && rule.params.columns) {
                    // This part of logic is complex, for now we rely on top-level source_table.
                }
            }
            return Array.from(sourceTables);
        }

        function updateColumnUIs() {
            document.querySelectorAll('.mapping-info-badge').forEach(b => b.remove());
            document.querySelectorAll('.mapped, .mapped-target').forEach(el => el.classList.remove('mapped', 'mapped-target'));
            
            for(const pgTable in mappingRules) {
                for(const pgCol in mappingRules[pgTable]) {
                    const rule = mappingRules[pgTable][pgCol];
                    const targetEl = document.getElementById(`pg-${pgTable}-${pgCol}`);
                    if (!targetEl) continue;

                    let badgeText = `[${rule.type.toUpperCase()}]`;
                    if(rule.type === 'direct') {
                        badgeText = `[${rule.source_table}.${rule.value}]`;
                        const sourceEl = document.getElementById(`mysql-${rule.source_table}-${rule.value}`);
                        if(sourceEl) sourceEl.classList.add('mapped');
                    } else if(rule.type === 'static') {
                        badgeText = `[STATIC: ${rule.value}]`;
                    } else if (rule.type === 'auto-increment') {
                        badgeText = `[AUTO-INC]`;
                    } else if (rule.type === 'transformation') {
                        badgeText = `[${rule.function}]`;
                        if (rule.params && rule.params.parts) {
                            rule.params.parts.forEach(part => {
                                if (part.type === 'column') {
                                    const sourceEl = document.getElementById(`mysql-${rule.source_table}-${part.value}`);
                                    if(sourceEl) sourceEl.classList.add('mapped');
                                }
                            });
                        }
                    } else if (rule.type === 'lookup' || rule.type === 'target_lookup' || rule.type === 'basic_target_lookup') {
                        badgeText = rule.type.includes('target') ? `[T-LOOKUP]` : `[S-LOOKUP]`;
                        const sourceTables = findSourceTablesForTarget(pgTable).length > 0 ? findSourceTablesForTarget(pgTable) : Object.keys(mysqlSchemaData);
                        sourceTables.forEach(tableName => {
                            const sourceEl = document.getElementById(`mysql-${tableName}-${rule.match_col}`);
                            if (sourceEl) sourceEl.classList.add('mapped');
                        });
                    } else if (rule.type === 'group_and_aggregate') {
                        badgeText = `[AGG]`;
                        const sourceEl = document.getElementById(`mysql-${rule.source_table}-${rule.group_by_column}`);
                        if (sourceEl) sourceEl.classList.add('mapped');
                        const sourceEl2 = document.getElementById(`mysql-${rule.source_table}-${rule.aggregate_column}`);
                        if (sourceEl2) sourceEl2.classList.add('mapped');
                    }

                    if (rule.post_transform) {
                        if (rule.post_transform.date_format && rule.post_transform.date_format.from) {
                            badgeText += ' [DATE]';
                        }
                        if (rule.post_transform.cast_to) {
                            badgeText += ` [${rule.post_transform.cast_to.toUpperCase()}]`;
                        }
                    }

                    const badge = document.createElement('span');
                    badge.className = 'mapping-info-badge';
                    badge.textContent = badgeText;
                    badge.title = JSON.stringify(rule, null, 2);
                    targetEl.querySelector('.flex').appendChild(badge);
                    targetEl.classList.add('mapped-target');
                }
            }
            drawMappingLines();
        }

        function drawMappingLines() {
            const svg = document.getElementById('mapping-svg');
            svg.innerHTML = svg.querySelector('defs').outerHTML; // Clear previous lines
            const containerRect = document.getElementById('mapping-container').getBoundingClientRect();

            for(const pgTable in mappingRules) {
                for(const pgCol in mappingRules[pgTable]) {
                    const rule = mappingRules[pgTable][pgCol];
                    const targetEl = document.getElementById(`pg-${pgTable}-${pgCol}`);
                    if (!targetEl || targetEl.offsetParent === null) continue;

                    const drawLineFromSource = (sourceEl) => {
                        if (sourceEl && sourceEl.offsetParent !== null) {
                            const sourceRect = sourceEl.getBoundingClientRect();
                            const targetRect = targetEl.getBoundingClientRect();
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', sourceRect.right - containerRect.left);
                            line.setAttribute('y1', sourceRect.top + sourceRect.height / 2 - containerRect.top);
                            line.setAttribute('x2', targetRect.left - containerRect.left);
                            line.setAttribute('y2', targetRect.top + targetRect.height / 2 - containerRect.top);
                            line.classList.add('mapped-line');
                            svg.appendChild(line);
                        }
                    };

                    if (rule.type === 'direct') {
                        drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${rule.value}`));
                    } else if (rule.type === 'transformation' && rule.params && rule.params.parts) {
                         rule.params.parts.forEach(part => {
                            if (part.type === 'column') {
                                drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${part.value}`));
                            }
                        });
                    } else if (rule.type === 'lookup' || rule.type === 'target_lookup' || rule.type === 'basic_target_lookup') {
                        const sourceTables = findSourceTablesForTarget(pgTable).length > 0 ? findSourceTablesForTarget(pgTable) : Object.keys(mysqlSchemaData);
                        sourceTables.forEach(tableName => {
                            drawLineFromSource(document.getElementById(`mysql-${tableName}-${rule.match_col}`));
                        });
                    } else if (rule.type === 'group_and_aggregate') {
                        drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${rule.group_by_column}`));
                        drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${rule.aggregate_column}`));
                    }
                }
            }
        }
        window.addEventListener('resize', drawMappingLines);

        // --- Modals & Panels ---
        function openMappingPanel(pgTable, pgCol) {
            const modal = document.getElementById('mapping-panel-modal');
            const content = document.getElementById('mapping-panel-content');
            const currentRule = mappingRules[pgTable]?.[pgCol.name] || {};
            let html = `<h2 class="text-2xl font-bold mb-4">Set Mapping for ${pgTable}.${pgCol.name}</h2>`;
            html += `
                <div class="mb-4">
                    <label class="block font-semibold mb-1">Mapping Type</label>
                    <select id="mapping-type-selector" class="w-full p-2 border rounded-md">
                        <option value="none">-- None --</option>
                        <option value="direct">Direct Mapping (from Source)</option>
                        <option value="transformation">Transformation (e.g., CONCAT)</option>
                        <option value="group_and_aggregate">Group and Aggregate to Array</option>
                        <option value="lookup">Lookup from another Source Table</option>
                        <option value="target_lookup">Lookup from Target DB Table</option>
                        <option value="basic_target_lookup">Basic Target Lookup (Direct Query)</option>
                        <option value="static">Static Value</option>
                        <option value="auto-increment">Auto-Increment</option>
                    </select>
                </div>
                <div id="mapping-options" class="space-y-4 border-t pt-4"></div>
                
                <!-- Post-Processing Transformations -->
                <div id="post-processing-container" class="mt-6 border-t pt-4">
                    <h3 class="font-semibold text-lg mb-2">Post-Processing</h3>
                    <p class="text-sm text-gray-600 mb-3">Apply transformations after the main value is determined.</p>
                    <div class="space-y-4">
                        <div>
                            <label class="block font-semibold text-sm mb-1">Change Data Type (Cast)</label>
                            <select id="post-transform-cast" class="w-full p-2 border rounded-md">
                                <option value="">-- Don't Change --</option>
                                <option value="string">String</option>
                                <option value="integer">Integer</option>
                                <option value="float">Float</option>
                                <option value="boolean">Boolean</option>
                            </select>
                        </div>
                        <div>
                            <label class="block font-semibold text-sm mb-1">Re-format Date</label>
                            <div class="grid grid-cols-2 gap-2">
                                <input type="text" id="post-transform-date-from" class="w-full p-2 border rounded-md" placeholder="Source Format (e.g., %Y-%m-%d)">
                                <input type="text" id="post-transform-date-to" class="w-full p-2 border rounded-md" placeholder="Target Format (e.g., %d %B %Y)">
                            </div>
                             <p class="text-xs text-gray-500 mt-1">Uses Python strptime/strftime format codes. Leave blank to disable.</p>
                        </div>
                    </div>
                </div>

                <!-- Fallback Options -->
                <div id="fallback-container" class="mt-6 border-t pt-4">
                    <h3 class="font-semibold text-lg mb-2">Fallback for Empty/Null Values</h3>
                    <p class="text-sm text-gray-600 mb-3">If the mapping result is empty or NULL, use this fallback. This is ignored for Static and Auto-Increment mapping types.</p>
                    <div class="flex items-center mb-3">
                        <input type="checkbox" id="fallback-enabled-checkbox" class="h-4 w-4">
                        <label for="fallback-enabled-checkbox" class="ml-2">Enable Fallback</label>
                    </div>
                    <div id="fallback-options-container" class="hidden space-y-4">
                        <select id="fallback-type-selector" class="w-full p-2 border rounded-md">
                            <option value="static">Static Value</option>
                            <option value="auto-increment">Auto-Increment</option>
                            <option value="set_null">Set NULL</option>
                        </select>
                        <div id="fallback-options"></div>
                    </div>
                </div>
                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" onclick="closeMappingPanelModal()" class="px-4 py-2 bg-gray-200 rounded-md">Cancel</button>
                    <button type="button" onclick="saveMappingRule('${pgTable}', '${pgCol.name}')" class="px-4 py-2 bg-blue-600 text-white rounded-md">Save Mapping</button>
                </div>
            `;
            content.innerHTML = html;

            const typeSelector = document.getElementById('mapping-type-selector');
            const fallbackEnabledCheckbox = document.getElementById('fallback-enabled-checkbox');
            const fallbackContainer = document.getElementById('fallback-options-container');
            const fallbackTypeSelector = document.getElementById('fallback-type-selector');

            typeSelector.onchange = () => {
                const type = typeSelector.value;
                const isFallbackDisabled = ['static', 'auto-increment', 'none'].includes(type);
                const isPostProcessingDisabled = ['group_and_aggregate', 'none'].includes(type);
                
                document.getElementById('fallback-container').style.display = isFallbackDisabled ? 'none' : 'block';
                document.getElementById('post-processing-container').style.display = isPostProcessingDisabled ? 'none' : 'block';

                renderMappingOptions(pgTable, pgCol.name);
            };
            fallbackEnabledCheckbox.onchange = () => {
                fallbackContainer.classList.toggle('hidden', !fallbackEnabledCheckbox.checked);
            };
            fallbackTypeSelector.onchange = () => renderFallbackOptions(currentRule.on_null);

            if (currentRule.type) {
                typeSelector.value = currentRule.type;
            }
            if(currentRule.on_null) {
                fallbackEnabledCheckbox.checked = true;
                fallbackContainer.classList.remove('hidden');
                fallbackTypeSelector.value = currentRule.on_null.type;
            }
            if (currentRule.post_transform) {
                const castSelect = document.getElementById('post-transform-cast');
                const dateFromInput = document.getElementById('post-transform-date-from');
                const dateToInput = document.getElementById('post-transform-date-to');
                if (currentRule.post_transform.cast_to) {
                    castSelect.value = currentRule.post_transform.cast_to;
                }
                if (currentRule.post_transform.date_format) {
                    dateFromInput.value = currentRule.post_transform.date_format.from || '';
                    dateToInput.value = currentRule.post_transform.date_format.to || '';
                }
            }

            typeSelector.dispatchEvent(new Event('change'));
            renderFallbackOptions(currentRule.on_null);
            modal.classList.remove('hidden');
        }

        function renderMappingOptions(pgTable, pgCol) {
            const container = document.getElementById('mapping-options');
            const type = document.getElementById('mapping-type-selector').value;
            const currentRule = mappingRules[pgTable]?.[pgCol] || {};
            let html = '';

            const createSelect = (id, label, options) => `<div><label class="block font-semibold text-sm mb-1">${label}</label><select id="${id}" class="w-full p-2 border rounded-md">${options}</select></div>`;
            const createInput = (id, label, value, type='text') => `<div><label class="block font-semibold text-sm mb-1">${label}</label><input type="${type}" id="${id}" class="w-full p-2 border rounded-md" value="${escapeHtml(value)}"></div>`;

            if (type === 'direct') {
                let allSourceCols = '';
                Object.keys(mysqlSchemaData).sort().forEach(t => {
                    mysqlSchemaData[t].columns.forEach(c => {
                        allSourceCols += `<option value="${c.name}" data-table="${t}">${t}.${c.name}</option>`
                    })
                });
                html = createSelect('direct-source-col', 'Source Column', allSourceCols);
            } else if (type === 'static') {
                html = createInput('static-value', 'Static Value', currentRule.value || '');
            } else if (type === 'auto-increment') {
                html = createInput('auto-inc-start', 'Start Number', currentRule.start || 1, 'number');
                html += createInput('auto-inc-step', 'Step', currentRule.step || 1, 'number');
            } else if (type === 'lookup' || type === 'target_lookup' || type === 'basic_target_lookup') {
                const isTargetLookup = type === 'target_lookup' || type === 'basic_target_lookup';
                const lookupSchema = isTargetLookup ? postgresSchemaData : mysqlSchemaData;
                const lookupTableOptions = Object.keys(lookupSchema).sort().map(t => `<option value="${t}">${t}</option>`).join('');
                const lookupLabel = isTargetLookup ? 'Target (PostgreSQL)' : 'Source (MySQL)';

                let matchColOptions = '';
                const sourceTablesInvolved = findSourceTablesForTarget(pgTable).length > 0 ? findSourceTablesForTarget(pgTable) : Object.keys(mysqlSchemaData);
                const uniqueColNames = new Set();
                sourceTablesInvolved.forEach(tableName => {
                    mysqlSchemaData[tableName]?.columns.forEach(col => uniqueColNames.add(col.name));
                });
                Array.from(uniqueColNames).sort().forEach(colName => {
                    matchColOptions += `<option value="${colName}">${colName}</option>`;
                });

                if (type === 'basic_target_lookup') {
                         html = `
                            <p class="text-sm font-bold text-gray-700">This performs a direct query on the target DB for each row. Use with caution.</p>
                            ${createSelect('lookup-table', 'Lookup From PG Table', lookupTableOptions)}
                            ${createSelect('lookup-get-col', 'Get this column', '')}
                            ${createSelect('lookup-match-col', 'Match using this column from the source row.', matchColOptions)}
                            ${createInput('where-clause-input', 'WHERE Clause (use {value} for placeholder)', currentRule.where_clause || '')}
                            ${createInput('order-by-clause-input', 'ORDER BY Clause (optional)', currentRule.order_by_clause || '')}
                            ${createInput('lookup-default-val', 'Default value if not found (optional)', currentRule.default || '')}
                        `;
                } else {
                        html = `
                            <p class="text-sm font-bold text-gray-700">1. Find a row in another ${lookupLabel} table...</p>
                            ${createSelect('lookup-table', `Lookup From ${lookupLabel} Table`, lookupTableOptions)}
                            ${createSelect('lookup-where-col', '...where this column...', '')}
                            <p class="text-sm font-bold text-gray-700 mt-2">2. ...matches a value from the current source row.</p>
                            ${createSelect('lookup-match-col', '...using this column from the source row.', matchColOptions)}
                            <p class="text-sm font-bold text-gray-700 mt-2">3. Then get the result.</p>
                            ${createSelect('lookup-get-col', 'Get value from this column in the found row', '')}
                            ${createInput('lookup-default-val', 'Default value if not found (optional)', currentRule.default || '')}
                        `;
                }
            } else if (type === 'transformation') {
                const tableOptions = Object.keys(mysqlSchemaData).sort().map(t => `<option value="${t}">${t}</option>`).join('');
                html = createSelect('transform-source-table', 'Source Table for Transformation', tableOptions);
                html += createSelect('transform-function', 'Function', '<option value="CONCAT">CONCAT</option>');
                html += `<div id="transform-params" class="p-2 border rounded-md bg-gray-50 space-y-2 mt-2"></div>`;
            } else if (type === 'group_and_aggregate') {
                const tableOptions = Object.keys(mysqlSchemaData).sort().map(t => `<option value="${t}">${t}</option>`).join('');
                html = createSelect('aggregate-source-table', 'Source Table for Aggregation', tableOptions);
                html += `<div id="aggregate-cols-container" class="space-y-2 mt-2"></div>`;
            }
            container.innerHTML = html;

            if (type === 'direct' && currentRule.value) {
                const colSelect = document.getElementById('direct-source-col');
                const optionToSelect = colSelect.querySelector(`option[value="${currentRule.value}"][data-table="${currentRule.source_table}"]`);
                if(optionToSelect) optionToSelect.selected = true;
            } else if (type === 'lookup' || type === 'target_lookup' || type === 'basic_target_lookup') {
                const isTargetLookup = type === 'target_lookup' || type === 'basic_target_lookup';
                const lookupSchema = isTargetLookup ? postgresSchemaData : mysqlSchemaData;
                const lookupTableSelect = document.getElementById('lookup-table');
                const getColSelect = document.getElementById('lookup-get-col');
                const whereColSelect = document.getElementById('lookup-where-col');
                const matchColSelect = document.getElementById('lookup-match-col');

                const updateLookupCols = () => {
                    const selectedTable = lookupTableSelect.value;
                    const cols = lookupSchema[selectedTable]?.columns || [];
                    const options = cols.map(c => `<option value="${c.name}">${c.name}</option>`).join('');
                    if(getColSelect) getColSelect.innerHTML = options;
                    if(whereColSelect) whereColSelect.innerHTML = options;
                };

                lookupTableSelect.onchange = updateLookupCols;
                if(currentRule.lookup_table || currentRule.lookup_source_table) lookupTableSelect.value = currentRule.lookup_table || currentRule.lookup_source_table;
                updateLookupCols();
                
                if(currentRule.get_col) getColSelect.value = currentRule.get_col;
                if(currentRule.where_col) whereColSelect.value = currentRule.where_col;
                if(currentRule.match_col) matchColSelect.value = currentRule.match_col;
            } else if (type === 'transformation') {
                const tableSelect = document.getElementById('transform-source-table');
                const functionSelect = document.getElementById('transform-function');
                const renderTransformParams = () => {
                    const paramsContainer = document.getElementById('transform-params');
                    if (functionSelect.value === 'CONCAT') {
                        paramsContainer.innerHTML = `
                            <p class="text-sm font-medium">CONCAT Builder</p>
                            <div id="concat-parts-container" class="space-y-2"></div>
                            <button type="button" onclick="addConcatPart()" class="text-xs text-blue-600 hover:underline">+ Add Part</button>
                        `;
                        const parts = currentRule.params?.parts || [
                            { type: 'column', value: '' }, 
                            { type: 'separator', value: ' ' }, 
                            { type: 'column', value: '' }
                        ];
                        renderConcatParts(parts);
                    }
                };
                tableSelect.onchange = renderTransformParams;
                functionSelect.onchange = renderTransformParams;
                if(currentRule.source_table) tableSelect.value = currentRule.source_table;
                renderTransformParams();
            } else if (type === 'group_and_aggregate') {
                const tableSelect = document.getElementById('aggregate-source-table');
                const renderAggregateParams = () => {
                    const paramsContainer = document.getElementById('aggregate-cols-container');
                    const colOptions = mysqlSchemaData[tableSelect.value].columns.map(c => `<option value="${c.name}">${c.name}</option>`).join('');
                    paramsContainer.innerHTML = `
                        ${createSelect('aggregate-group-by-col', 'Group By This Column', colOptions)}
                        ${createSelect('aggregate-aggregate-col', 'Collect Values From This Column', colOptions)}
                    `;
                    if (currentRule.group_by_column) {
                        document.getElementById('aggregate-group-by-col').value = currentRule.group_by_column;
                    }
                    if (currentRule.aggregate_column) {
                        document.getElementById('aggregate-aggregate-col').value = currentRule.aggregate_column;
                    }
                };
                tableSelect.onchange = renderAggregateParams;
                if (currentRule.source_table) {
                    tableSelect.value = currentRule.source_table;
                }
                renderAggregateParams();
            }
        }
        
        // --- CONCAT Builder Functions ---
        function renderConcatParts(parts) {
            const container = document.getElementById('concat-parts-container');
            container.innerHTML = ''; // Clear existing
            const sourceTable = document.getElementById('transform-source-table').value;
            const colOptions = mysqlSchemaData[sourceTable]?.columns.map(c => `<option value="${c.name}">${c.name}</option>`).join('') || '';

            parts.forEach((part, index) => {
                const partDiv = document.createElement('div');
                partDiv.className = 'flex items-center space-x-2 p-2 border rounded-md bg-white';
                partDiv.dataset.index = index;

                let partHtml = `
                    <select class="p-1 border rounded-md text-sm part-type-select" onchange="handleConcatPartTypeChange(this)">
                        <option value="column" ${part.type === 'column' ? 'selected' : ''}>Column</option>
                        <option value="static" ${part.type === 'static' ? 'selected' : ''}>Static Text</option>
                        <option value="separator" ${part.type === 'separator' ? 'selected' : ''}>Separator</option>
                        <option value="auto-increment" ${part.type === 'auto-increment' ? 'selected' : ''}>Auto-Increment</option>
                    </select>
                    <div class="part-value-container flex-grow"></div>
                    <button type="button" onclick="removeConcatPart(this)" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
                `;
                partDiv.innerHTML = partHtml;
                container.appendChild(partDiv);
                
                const valueContainer = partDiv.querySelector('.part-value-container');
                renderConcatPartValueInput(valueContainer, part, colOptions);
            });
        }

        function renderConcatPartValueInput(container, part, colOptions) {
            let inputHtml = '';
            switch(part.type) {
                case 'column':
                    inputHtml = `<select class="w-full p-1 border rounded-md text-sm part-value">${colOptions}</select>`;
                    break;
                case 'static':
                case 'separator':
                    inputHtml = `<input type="text" class="w-full p-1 border rounded-md text-sm part-value" placeholder="Enter text" value="${escapeHtml(part.value || '')}">`;
                    break;
                case 'auto-increment':
                    inputHtml = `
                        <div class="flex space-x-1 text-sm">
                            <input type="text" class="w-1/2 p-1 border rounded-md part-value" placeholder="Counter Name (unique)" value="${escapeHtml(part.key || '')}">
                            <input type="number" class="w-1/4 p-1 border rounded-md part-start" placeholder="Start" value="${escapeHtml(part.start || 1)}">
                            <input type="number" class="w-1/4 p-1 border rounded-md part-step" placeholder="Step" value="${escapeHtml(part.step || 1)}">
                        </div>`;
                    break;
            }
            container.innerHTML = inputHtml;

            if (part.type === 'column' && part.value) {
                container.querySelector('.part-value').value = part.value;
            }
        }

        function handleConcatPartTypeChange(selectElement) {
            const partDiv = selectElement.closest('.flex');
            const valueContainer = partDiv.querySelector('.part-value-container');
            const sourceTable = document.getElementById('transform-source-table').value;
            const colOptions = mysqlSchemaData[sourceTable]?.columns.map(c => `<option value="${c.name}">${c.name}</option>`).join('') || '';
            renderConcatPartValueInput(valueContainer, { type: selectElement.value }, colOptions);
        }

        function addConcatPart() {
            const parts = readConcatPartsFromUI();
            parts.push({ type: 'separator', value: ' ' });
            renderConcatParts(parts);
        }

        function removeConcatPart(buttonElement) {
            const partDiv = buttonElement.closest('.flex');
            const index = parseInt(partDiv.dataset.index, 10);
            const parts = readConcatPartsFromUI();
            parts.splice(index, 1);
            renderConcatParts(parts);
        }

        function readConcatPartsFromUI() {
            const parts = [];
            document.querySelectorAll('#concat-parts-container > div').forEach(partDiv => {
                const type = partDiv.querySelector('.part-type-select').value;
                const newPart = { type };
                if (type === 'column') {
                    newPart.value = partDiv.querySelector('.part-value').value;
                } else if (type === 'static' || type === 'separator') {
                    newPart.value = partDiv.querySelector('.part-value').value;
                } else if (type === 'auto-increment') {
                    newPart.key = partDiv.querySelector('.part-value').value;
                    newPart.start = parseInt(partDiv.querySelector('.part-start').value, 10) || 1;
                    newPart.step = parseInt(partDiv.querySelector('.part-step').value, 10) || 1;
                }
                parts.push(newPart);
            });
            return parts;
        }


        function renderFallbackOptions(currentFallbackRule = {}) {
            const container = document.getElementById('fallback-options');
            const type = document.getElementById('fallback-type-selector').value;
            let html = '';
            const createInput = (id, label, value, type='text') => `<div><label class="block font-semibold text-sm mb-1">${label}</label><input type="${type}" id="${id}" class="w-full p-2 border rounded-md" value="${escapeHtml(value)}"></div>`;

            if (type === 'static') {
                html = createInput('fallback-static-value', 'Fallback Static Value', currentFallbackRule.value || '');
            } else if (type === 'auto-increment') {
                html = createInput('fallback-auto-inc-start', 'Start Number', currentFallbackRule.start || 1, 'number');
                html += createInput('fallback-auto-inc-step', 'Step', currentFallbackRule.step || 1, 'number');
            } else if (type === 'set_null') {
                html = `<p class="text-sm text-gray-500 p-2">The final value will be set to NULL if the mapping returns an empty result.</p>`;
            }
            container.innerHTML = html;
        }

        function convertRoleToInt(roleString) {
            const roleMap = {
                'admin': 1,
                'teacher': 2,
                'student': 3
            };
            return roleMap[String(roleString).toLowerCase()] || roleString;
        }

        function saveMappingRule(pgTable, pgCol) {
            if (!mappingRules[pgTable]) mappingRules[pgTable] = {};
            const type = document.getElementById('mapping-type-selector').value;
            if (type === 'none') {
                delete mappingRules[pgTable][pgCol];
                if (Object.keys(mappingRules[pgTable]).length === 0) {
                    delete mappingRules[pgTable];
                }
            } else {
                let newRule = { type };
                
                const isRoleIdColumn = pgCol.toLowerCase() === 'role_id';
                
                if (type === 'direct') {
                    const selectedOption = document.getElementById('direct-source-col').selectedOptions[0];
                    newRule.value = selectedOption.value;
                    newRule.source_table = selectedOption.dataset.table;
                } else if (type === 'static') {
                    const staticValue = document.getElementById('static-value').value;
                    newRule.value = isRoleIdColumn ? convertRoleToInt(staticValue) : staticValue;
                } else if (type === 'auto-increment') {
                    newRule.start = parseInt(document.getElementById('auto-inc-start').value);
                    newRule.step = parseInt(document.getElementById('auto-inc-step').value);
                } else if (type === 'transformation') {
                    newRule.source_table = document.getElementById('transform-source-table').value;
                    newRule.function = document.getElementById('transform-function').value;
                    if (newRule.function === 'CONCAT') {
                        newRule.params = { parts: readConcatPartsFromUI() };
                    }
                } else if (type === 'group_and_aggregate') {
                    newRule.source_table = document.getElementById('aggregate-source-table').value;
                    newRule.group_by_column = document.getElementById('aggregate-group-by-col').value;
                    newRule.aggregate_column = document.getElementById('aggregate-aggregate-col').value;
                } else if (type === 'lookup' || type === 'target_lookup' || type === 'basic_target_lookup') {
                    if (type === 'lookup') newRule.lookup_source_table = document.getElementById('lookup-table').value;
                    else newRule.lookup_table = document.getElementById('lookup-table').value;
                    
                    newRule.get_col = document.getElementById('lookup-get-col').value;
                    newRule.match_col = document.getElementById('lookup-match-col').value;
                    newRule.default = document.getElementById('lookup-default-val').value;

                    if(type !== 'basic_target_lookup') newRule.where_col = document.getElementById('lookup-where-col').value;
                    else {
                        newRule.where_clause = document.getElementById('where-clause-input').value;
                        newRule.order_by_clause = document.getElementById('order-by-clause-input').value;
                    }

                    if (isRoleIdColumn && newRule.default) {
                        newRule.default = convertRoleToInt(newRule.default);
                    }
                }

                // --- Save Post-Processing and Fallback Rules ---
                const postTransform = {};
                const castTo = document.getElementById('post-transform-cast').value;
                const dateFrom = document.getElementById('post-transform-date-from').value;
                const dateTo = document.getElementById('post-transform-date-to').value;

                if (castTo) {
                    postTransform.cast_to = castTo;
                }
                if (dateFrom && dateTo) {
                    postTransform.date_format = { from: dateFrom, to: dateTo };
                }
                if (Object.keys(postTransform).length > 0) {
                    newRule.post_transform = postTransform;
                }


                if (document.getElementById('fallback-enabled-checkbox').checked && !['static', 'auto-increment'].includes(type)) {
                    const fallbackType = document.getElementById('fallback-type-selector').value;
                    let fallbackRule = { type: fallbackType };
                    if (fallbackType === 'static') {
                        let fallbackValue = document.getElementById('fallback-static-value').value;
                        fallbackRule.value = isRoleIdColumn ? convertRoleToInt(fallbackValue) : fallbackValue;
                    } else if (fallbackType === 'auto-increment') {
                        fallbackRule.start = parseInt(document.getElementById('fallback-auto-inc-start').value);
                        fallbackRule.step = parseInt(document.getElementById('fallback-auto-inc-step').value);
                    }
                    newRule.on_null = fallbackRule;
                }
                mappingRules[pgTable][pgCol] = newRule;
            }
            updateColumnUIs();
            closeMappingPanelModal();
        }

        function openSettingsModal(tableName) {
            const modal = document.getElementById('settings-modal');
            const content = document.getElementById('settings-modal-content');
            const tableFilters = migrationFilters[tableName] || {};
            const tableSort = tableFilters.sort || {};
            let colOptions = '<option value="">-- No Sorting --</option>';
            mysqlSchemaData[tableName].columns.forEach(col => {
                colOptions += `<option value="${col.name}" ${tableSort.column === col.name ? 'selected' : ''}>${col.name}</option>`;
            });

            let html = `<h2 class="text-2xl font-bold mb-4">Settings for ${tableName}</h2>`;
            html += `<div class="mb-4 border-b pb-4">
                        <h3 class="font-semibold mb-2">Data Merging (for multi-table sources)</h3>
                        <p class="text-sm text-gray-600 mb-2">If mapping from multiple source tables to one target, specify the column used to link rows from this table to others (e.g., 'id', 'user_id').</p>
                        <input type="text" id="merge-key-input" class="w-full p-2 border rounded-md" placeholder="e.g., id" value="${escapeHtml(tableFilters.merge_key || 'id')}">
                    </div>`;
            html += `<div class="mb-4 border-b pb-4">
                        <h3 class="font-semibold mb-2">Sort Source Data</h3>
                        <p class="text-sm text-gray-600 mb-2">Sort data before processing. Note: This is only applied when this is the only source table for a mapping.</p>
                        <div class="flex space-x-2">
                            <select id="sort-column-select" class="w-2/3 p-2 border rounded-md">${colOptions}</select>
                            <select id="sort-order-select" class="w-1/3 p-2 border rounded-md">
                                <option value="ASC" ${tableSort.order === 'ASC' ? 'selected' : ''}>Ascending</option>
                                <option value="DESC" ${tableSort.order === 'DESC' ? 'selected' : ''}>Descending</option>
                            </select>
                        </div>
                    </div>`;
            html += `<div class="mb-6"><label class="block font-semibold mb-1">WHERE Clause (Filter Rows)</label>`;
            html += `<input type="text" id="where-clause-input" class="w-full p-2 border rounded-md" placeholder="e.g., role = 'teacher' AND status != 'inactive'" value="${escapeHtml(tableFilters.where || '')}"></div>`;
            html += `<div class="mb-4"><h3 class="font-semibold mb-2">Value Replacements</h3><div class="space-y-3">`;
            mysqlSchemaData[tableName].columns.forEach(col => {
                html += `<div class="p-2 border-t"><p class="font-medium">${col.name}</p><div id="replacements-for-${col.name}" class="space-y-2 mt-2"></div>`;
                html += `<button type="button" onclick="addReplacementRule('${tableName}', '${col.name}')" class="text-sm text-blue-600 hover:underline mt-2">+ Add Replacement</button></div>`;
            });
            html += `</div></div>`;
            html += `<div class="flex justify-end space-x-4 mt-6"><button type="button" onclick="closeSettingsModal()" class="px-4 py-2 bg-gray-200 rounded-md">Cancel</button><button type="button" onclick="saveSettings('${tableName}')" class="px-4 py-2 bg-blue-600 text-white rounded-md">Save Settings</button></div>`;
            
            content.innerHTML = html;
            
            if (tableFilters.replacements) {
                for (const colName in tableFilters.replacements) {
                    tableFilters.replacements[colName].forEach(rule => addReplacementRule(tableName, colName, rule.find, rule.replace));
                }
            }
            modal.classList.remove('hidden');
        }

        function addReplacementRule(tableName, colName, findVal = '', replaceVal = '') {
            const container = document.getElementById(`replacements-for-${colName}`);
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'flex items-center space-x-2';
            ruleDiv.innerHTML = `
                <input type="text" class="w-1/2 p-1 border rounded-md text-sm find-input" placeholder="Find this value" value="${escapeHtml(findVal)}">
                <span class="font-bold text-gray-500">→</span>
                <input type="text" class="w-1/2 p-1 border rounded-md text-sm replace-input" placeholder="Replace with this" value="${escapeHtml(replaceVal)}">
                <button type="button" onclick="this.parentElement.remove()" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
            `;
            container.appendChild(ruleDiv);
        }

        function saveSettings(tableName) {
            if (!migrationFilters[tableName]) {
                migrationFilters[tableName] = {};
            }
            migrationFilters[tableName].merge_key = document.getElementById('merge-key-input').value || 'id';

            const sortColumn = document.getElementById('sort-column-select').value;
            if (sortColumn) {
                migrationFilters[tableName].sort = {
                    column: sortColumn,
                    order: document.getElementById('sort-order-select').value
                };
            } else {
                delete migrationFilters[tableName].sort;
            }
            migrationFilters[tableName].where = document.getElementById('where-clause-input').value;
            const replacements = {};
            mysqlSchemaData[tableName].columns.forEach(col => {
                const container = document.getElementById(`replacements-for-${col.name}`);
                const rules = [];
                container.querySelectorAll('.flex').forEach(ruleDiv => {
                    const find = ruleDiv.querySelector('.find-input').value;
                    const replace = ruleDiv.querySelector('.replace-input').value;
                    if (find) {
                        rules.push({ find, replace });
                    }
                });
                if (rules.length > 0) {
                    replacements[col.name] = rules;
                }
            });
            migrationFilters[tableName].replacements = replacements;
            closeSettingsModal();
        }

        async function viewColumnData(tableName, columnName) {
            const modal = document.getElementById('data-preview-modal');
            const content = document.getElementById('data-preview-content');
            modal.classList.remove('hidden');
            content.innerHTML = `<h2 class="text-2xl font-bold mb-4">Previewing ${tableName}.${columnName}</h2><p>Loading data...</p>`;
            
            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let payload = {};
            if (selector.value === 'custom') {
                payload = { path: customPathInput.value, tableName, columnName };
            } else if (selector.value) {
                payload = { filename: selector.value, tableName, columnName };
            } else {
                alert("Please select a SQL file first.");
                closeDataPreviewModal();
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/get_column_data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to fetch column data.');
                
                let listHtml = `<p class="text-sm text-gray-600 mb-2">Showing ${data.unique_values.length} unique values (out of ${data.total_rows} total rows).</p>`;
                listHtml += '<ul class="data-preview-list border rounded-md p-2 bg-gray-50">';
                if (data.unique_values.length === 0) {
                    listHtml += '<li class="p-1 text-gray-500">No data found for this column.</li>';
                } else {
                    data.unique_values.forEach(val => {
                        listHtml += `<li class="p-1 border-b">${escapeHtml(val) || '<em>NULL or Empty</em>'}</li>`;
                    });
                }
                listHtml += '</ul>';
                
                content.innerHTML = `
                    <div class="flex justify-between items-start">
                        <h2 class="text-2xl font-bold mb-4">Previewing ${tableName}.${columnName}</h2>
                        <button type="button" onclick="closeDataPreviewModal()" class="text-2xl font-bold">&times;</button>
                    </div>
                    ${listHtml}
                `;
            } catch (error) {
                content.innerHTML = `<p class="text-red-500">Error: ${error.message}</p> <button type="button" onclick="closeDataPreviewModal()" class="mt-4 px-4 py-2 bg-gray-200 rounded-md">Close</button>`;
            }
        }

        async function viewSourceTable(tableName) {
            const modal = document.getElementById('data-preview-modal');
            const content = document.getElementById('data-preview-content');
            modal.classList.remove('hidden');
            content.innerHTML = `<h2 class="text-2xl font-bold mb-4">Viewing Full Data for ${tableName}</h2><p>Loading data...</p>`;

            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let payload = {};
            if (selector.value === 'custom') {
                payload = { path: customPathInput.value, tableName };
            } else if (selector.value) {
                payload = { filename: selector.value, tableName };
            } else {
                alert("Please select a SQL file first.");
                closeDataPreviewModal();
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/get_source_table_data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to fetch table data.');

                let tableHtml = `<div class="data-preview-list"><table class="data-preview-table"><thead><tr>`;
                data.headers.forEach(header => {
                    tableHtml += `<th>${escapeHtml(header)}</th>`;
                });
                tableHtml += `</tr></thead><tbody>`;
                data.rows.forEach(row => {
                    tableHtml += `<tr>`;
                    data.headers.forEach(header => {
                        tableHtml += `<td>${escapeHtml(row[header])}</td>`;
                    });
                    tableHtml += `</tr>`;
                });
                tableHtml += `</tbody></table></div>`;

                content.innerHTML = `
                    <div class="flex justify-between items-start">
                        <h2 class="text-2xl font-bold mb-4">Full Data for ${tableName}</h2>
                        <button type="button" onclick="closeDataPreviewModal()" class="text-2xl font-bold">&times;</button>
                    </div>
                    ${tableHtml}
                `;
            } catch (error) {
                 content.innerHTML = `<p class="text-red-500">Error: ${error.message}</p> <button type="button" onclick="closeDataPreviewModal()" class="mt-4 px-4 py-2 bg-gray-200 rounded-md">Close</button>`;
            }
        }

        // --- Functions for Saving/Loading Mappings ---

        async function loadSavedMappings() {
            const selector = document.getElementById('savedMappingsSelector');
            try {
                const response = await fetch(`${API_BASE_URL}/api/get_mappings`);
                if (!response.ok) throw new Error('Failed to fetch mappings.');
                const mappings = await response.json();
                selector.innerHTML = '<option value="">-- Select a saved mapping --</option>';
                mappings.forEach(name => {
                    selector.innerHTML += `<option value="${name}">${name}</option>`;
                });
            } catch (error) {
                selector.innerHTML = '<option value="">-- Could not load mappings --</option>';
                handleFetchError(error, 'loading saved mappings');
            }
        }

        async function saveCurrentMapping() {
            const nameInput = document.getElementById('newMappingNameInput');
            const mappingName = nameInput.value.trim();
            if (!mappingName) {
                alert('Please enter a name for the mapping.');
                return;
            }
            if (Object.keys(mappingRules).length === 0) {
                alert('There are no mapping rules to save.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/save_mapping`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: mappingName, config: mappingRules })
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Failed to save mapping.');
                showStatus(result.message, false);
                nameInput.value = ''; // Clear input on success
                loadSavedMappings(); // Refresh the list
            } catch (error) {
                handleFetchError(error, 'saving mapping');
            }
        }

        async function loadSelectedMapping() {
            const selector = document.getElementById('savedMappingsSelector');
            const mappingName = selector.value;
            if (!mappingName) {
                alert('Please select a mapping to load.');
                return;
            }
            if (!mysqlSchemaData || Object.keys(mysqlSchemaData).length === 0 || !postgresSchemaData || Object.keys(postgresSchemaData).length === 0) {
                alert('Please load both source and target schemas before loading a mapping.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/load_mapping/${mappingName}`);
                const loadedRules = await response.json();
                if (!response.ok) throw new Error(loadedRules.error || 'Failed to load mapping.');

                mappingRules = loadedRules;
                
                const sourceTablesToDisplay = new Set();
                const targetTablesToDisplay = new Set();
                for (const pgTable in mappingRules) {
                    targetTablesToDisplay.add(pgTable);
                    for (const pgCol in mappingRules[pgTable]) {
                        const rule = mappingRules[pgTable][pgCol];
                        if (rule.source_table) {
                            sourceTablesToDisplay.add(rule.source_table);
                        }
                        if (rule.lookup_source_table) {
                             sourceTablesToDisplay.add(rule.lookup_source_table);
                        }
                    }
                }

                document.querySelectorAll('#mysql-table-filter input[type="checkbox"]').forEach(cb => {
                    cb.checked = sourceTablesToDisplay.has(cb.value);
                });
                document.querySelectorAll('#pg-table-filter input[type="checkbox"]').forEach(cb => {
                    cb.checked = targetTablesToDisplay.has(cb.value);
                });
                
                updateSourceTableVisibility();
                updateTargetTableVisibility();
                
                setTimeout(() => {
                    updateColumnUIs();
                    showStatus(`Mapping '${mappingName}' loaded successfully.`, false);
                }, 100);

            } catch (error) {
                handleFetchError(error, 'loading selected mapping');
            }
        }
        
        function closeSettingsModal() {
            document.getElementById('settings-modal').classList.add('hidden');
        }
        function closeMappingPanelModal() {
            document.getElementById('mapping-panel-modal').classList.add('hidden');
        }
        function closeDataPreviewModal() {
            document.getElementById('data-preview-modal').classList.add('hidden');
        }
    </script>
</body>
</html>
