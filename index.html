<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MySQL to PostgreSQL Migration Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f3f4f6;
        }
        .card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: box-shadow 0.3s ease-in-out;
        }
        .card:hover {
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .card-header {
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 1.5rem;
        }
        .btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #10b981;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #059669;
        }
        .btn-tertiary {
             background-color: #6b7280;
             color: white;
        }
        .btn-tertiary:hover {
            background-color: #4b5563;
        }
        .column-item:hover { background-color: #f0f4f8; }
        .mapped { background-color: #c6f6d5 !important; border-color: #38a169 !important; font-weight: 600; }
        .mapped-target { background-color: #e6fffa !important; border-color: #38b2ac !important; }
        .mapped-line { stroke: #4a5568; stroke-width: 2; marker-end: url(#arrow); }
        .dragging { opacity: 0.5; }
        #mapping-container { position: relative; }
        #mapping-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .table-filter-panel-content { max-height: 200px; overflow-y: auto; }
        .error-details { background-color: #2d3748; color: #e2e8f0; padding: 0.75rem; margin-top: 0.5rem; border-radius: 0.25rem; font-family: 'Courier New', Courier, monospace; font-size: 0.8rem; white-space: pre-wrap; word-break: break-all; }
        .data-type { font-size: 0.75rem; color: #718096; margin-left: 0.5rem; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 50; opacity: 0; transition: opacity 0.3s ease-in-out; pointer-events: none;}
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: white; padding: 2rem; border-radius: 0.5rem; width: 90vw; max-width: 800px; max-height: 90vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease-in-out;}
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .mapping-info-badge { font-size: 0.65rem; font-weight: bold; color: #2c5282; background-color: #bee3f8; padding: 2px 4px; border-radius: 4px; margin-left: auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; display: inline-block; vertical-align: middle;}
        .not-null-badge { font-size: 0.65rem; font-weight: bold; color: #c53030; background-color: #fed7d7; padding: 2px 4px; border-radius: 4px; margin-left: 0.5rem; }
        .data-preview-list { max-height: 400px; overflow-y: auto; }
        .data-preview-table { width: 100%; border-collapse: collapse; }
        .data-preview-table th, .data-preview-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .data-preview-table th { background-color: #f2f2f2; }
        .hidden { display: none !important; }

        /* AI Assistant Styles */
        #ai-assistant-button {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease-in-out;
        }
        #ai-assistant-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }
        #ai-chat-modal-overlay {
             z-index: 999;
        }
        #ai-chat-modal {
            width: 90vw;
            max-width: 700px;
            height: 80vh;
            max-height: 700px;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        #ai-chat-header {
            padding: 1rem;
            background: linear-gradient(to right, #4f46e5, #6366f1);
            color: white;
            font-weight: bold;
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #ai-chat-history {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            background-color: #f9fafb;
        }
        .chat-message {
            margin-bottom: 1rem;
            max-width: 90%;
            display: flex;
            flex-direction: column;
        }
        .user-message {
            background-color: #dbeafe;
            color: #1e40af;
            padding: 0.75rem 1rem;
            border-radius: 1rem 1rem 0.25rem 1rem;
            align-self: flex-end;
        }
        .ai-message {
            background-color: #e5e7eb;
            color: #1f2937;
            padding: 0.75rem 1rem;
            border-radius: 1rem 1rem 1rem 0.25rem;
            align-self: flex-start;
        }
        .ai-message h1, .ai-message h2, .ai-message h3 { font-weight: bold; margin-top: 0.5em; margin-bottom: 0.25em; }
        .ai-message h1 { font-size: 1.25rem; }
        .ai-message h2 { font-size: 1.1rem; }
        .ai-message h3 { font-size: 1rem; }
        .ai-message strong { font-weight: bold; }
        .ai-message em { font-style: italic; }
        .ai-message ul { list-style-type: disc; margin-left: 1.5rem; }
        .ai-message ol { list-style-type: decimal; margin-left: 1.5rem; }
        .ai-message code { background-color: #d1d5db; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-family: monospace; }
        .ai-message pre { background-color: #111827; color: #e5e7eb; padding: 0.5rem; border-radius: 0.25rem; overflow-x: auto; font-family: monospace; }
        #ai-chat-input-container {
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
        }
        #ai-chat-input {
            flex-grow: 1;
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: box-shadow 0.2s;
        }
        #ai-chat-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #4f46e5;
        }
        #ai-chat-send {
            margin-left: 0.5rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #ai-chat-send:hover {
            background-color: #4338ca;
        }
        .ask-ai-btn {
            background-color: #6366f1;
            color: white;
            padding: 2px 6px;
            font-size: 0.7rem;
            border-radius: 4px;
            margin-left: 8px;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 space-y-8">
        <header class="text-center py-8 bg-white rounded-xl shadow-sm">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">MySQL to PostgreSQL Migration Assistant</h1>
            <p class="text-md text-gray-600 mt-2">A powerful tool to streamline your database migration workflow.</p>
        </header>
        
        <div id="status-area" class="mb-4 p-4 text-center rounded-md hidden"></div>

        <!-- Saved Mappings Section -->
        <div id="saved-mappings-section" class="card">
             <h2 class="text-2xl font-semibold card-header">Manage Mappings</h2>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                 <div>
                     <label for="savedMappingsSelector" class="block text-sm font-medium text-gray-700 mb-1">Load Existing Mapping</label>
                     <div class="flex">
                         <select id="savedMappingsSelector" class="w-full p-2 border border-gray-300 rounded-l-md focus:ring-indigo-500 focus:border-indigo-500">
                              <option value="">-- Loading mappings... --</option>
                         </select>
                         <button id="loadMappingButton" type="button" class="btn btn-primary rounded-l-none">Load</button>
                     </div>
                 </div>
                 <div>
                     <label for="newMappingNameInput" class="block text-sm font-medium text-gray-700 mb-1">Save Current Mapping</label>
                     <div class="flex">
                         <input type="text" id="newMappingNameInput" placeholder="Enter a name for this mapping" class="w-full p-2 border border-gray-300 rounded-l-md focus:ring-indigo-500 focus:border-indigo-500">
                         <button id="saveMappingButton" type="button" class="btn btn-secondary rounded-l-none">Save</button>
                     </div>
                 </div>
             </div>
        </div>

        <!-- Step 1: Provide MySQL Dump File Path -->
        <div id="step1" class="card">
            <h2 class="text-2xl font-semibold card-header">Step 1: Select MySQL Dump File</h2>
            <p class="text-gray-600 mb-4">Select a file from the `sql_files` directory on the server, or provide a custom path.</p>
            <select id="sqlFileSelector" class="w-full p-2 border border-gray-300 rounded-md mb-2 focus:ring-indigo-500 focus:border-indigo-500">
                <option value="">-- Loading files... --</option>
            </select>
            <input type="text" id="sqlFilePathInput" placeholder="/path/to/your/dump.sql" class="w-full p-2 border border-gray-300 rounded-md hidden focus:ring-indigo-500 focus:border-indigo-500">
            <button id="parseSqlFileButton" type="button" class="mt-4 btn btn-primary">Parse SQL File</button>
        </div>

        <!-- Step 2: Connect to PostgreSQL -->
        <div id="step2" class="card hidden">
            <h2 class="text-2xl font-semibold card-header">Step 2: Connect to PostgreSQL</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <input type="text" id="pgHost" placeholder="Hostname (e.g., localhost)" class="p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" value="localhost">
                <input type="number" id="pgPort" value="5432" placeholder="Port" class="p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                <input type="text" id="pgUser" placeholder="Username" class="p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" value="postgres">
                <input type="password" id="pgPassword" placeholder="Password" class="p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" value="password">
            </div>
            <button id="fetchDatabasesButton" type="button" class="mt-4 btn btn-secondary">Connect & Fetch Databases</button>
        </div>
        
        <!-- Step 2b: Select Database -->
        <div id="step2b-db-select" class="card hidden">
            <h3 class="text-xl font-semibold mb-2">Select Target Database</h3>
            <select id="dbSelector" class="w-full p-2 border border-gray-300 rounded-md mb-4 focus:ring-indigo-500 focus:border-indigo-500"></select>
            <button id="fetchTablesButton" type="button" class="btn btn-secondary">Fetch Tables for Selected DB</button>
        </div>

        <!-- Step 3: Mapping Interface -->
        <div id="step3" class="hidden">
            <div class="card">
                <h2 class="text-2xl font-semibold card-header">Step 3: Map Tables and Columns</h2>
                <div id="mapping-container">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h3 class="text-xl font-semibold mb-4 text-blue-800">Source (MySQL)</h3>
                            <div id="mysql-table-filter" class="mb-4"></div>
                            <div id="mysqlSchema" class="space-y-4"></div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold mb-4 text-green-800">Target (PostgreSQL)</h3>
                            <div id="pg-table-filter" class="mb-4"></div>
                            <div id="postgresSchema" class="space-y-4"></div>
                        </div>
                    </div>
                    <svg id="mapping-svg">
                        <defs>
                            <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#4a5568" />
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Custom Commands Section -->
        <div id="step3b-custom-commands" class="card hidden">
            <h2 class="text-2xl font-semibold card-header">Custom SQL Commands (Optional)</h2>
            <p class="text-gray-600 mb-4">Enter SQL commands to run on the target database before or after the migration. Separate multiple commands with a semicolon (;).</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="pre-migration-commands" class="block text-sm font-medium text-gray-700 mb-1">Pre-Migration Commands</label>
                    <textarea id="pre-migration-commands" rows="4" class="w-full p-2 border border-gray-300 rounded-md font-mono text-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., CREATE EXTENSION IF NOT EXISTS &quot;uuid-ossp&quot;;"></textarea>
                </div>
                <div>
                    <label for="post-migration-commands" class="block text-sm font-medium text-gray-700 mb-1">Post-Migration Commands</label>
                    <textarea id="post-migration-commands" rows="4" class="w-full p-2 border border-gray-300 rounded-md font-mono text-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., CREATE INDEX idx_users_email ON users(email);"></textarea>
                </div>
            </div>
        </div>

        <!-- Step 4: Run Migration -->
        <div id="step4" class="card hidden text-center">
             <h2 class="text-2xl font-semibold card-header">Step 4: Execute Migration</h2>
            <div class="space-y-3 my-4">
                <label class="flex items-center justify-center cursor-pointer">
                    <input type="checkbox" id="truncateCheckbox" class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500">
                    <span class="ml-2 text-gray-700">Clear target tables before migrating (TRUNCATE)</span>
                </label>
                <label class="flex items-center justify-center cursor-pointer">
                    <input type="checkbox" id="upsertCheckbox" class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500">
                    <span class="ml-2 text-gray-700">Update existing records on conflict (Upsert on 'id' column)</span>
                </label>
            </div>
            <button id="runMigrationButton" type="button" class="mt-4 btn bg-purple-600 text-white hover:bg-purple-700 shadow-lg text-lg px-8 py-3">RUN MIGRATION</button>
        </div>

    </div>
    
    <!-- Modals -->
    <div id="settings-modal" class="modal-overlay">
        <div id="settings-modal-content" class="modal-content"></div>
    </div>
    <div id="mapping-panel-modal" class="modal-overlay">
        <div id="mapping-panel-content" class="modal-content"></div>
    </div>
    <div id="data-preview-modal" class="modal-overlay">
        <div id="data-preview-content" class="modal-content"></div>
    </div>

    <!-- AI Assistant -->
    <button id="ai-assistant-button">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
            <path d="M10 2a6 6 0 00-6 6v3.586l-1.707 1.707A1 1 0 003 15h4v1H7a1 1 0 100 2h6a1 1 0 100-2h-2v-1h4a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z" />
        </svg>
    </button>
    <div id="ai-chat-modal-overlay" class="modal-overlay">
        <div id="ai-chat-modal">
            <div id="ai-chat-header">
                <span>AI Migration Assistant</span>
                <button id="ai-chat-close" class="font-bold text-xl">&times;</button>
            </div>
            <div id="ai-chat-history">
                <div class="ai-message">Hello! I'm your migration assistant. How can I help you with this tool?</div>
            </div>
            <div id="ai-chat-input-container">
                <input type="text" id="ai-chat-input" placeholder="Ask a question...">
                <button id="ai-chat-send" class="btn btn-primary">Send</button>
            </div>
        </div>
    </div>


    <script>
        // Global state variables
        let mysqlSchemaData = {};
        let postgresSchemaData = {};
        let pgConnectionDetails = {};
        let mappingRules = {};
        let migrationFilters = {};
        const API_BASE_URL = "http://127.0.0.1:5000";

        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeStep1();

            // Attach event listeners to buttons
            document.getElementById('parseSqlFileButton').addEventListener('click', parseSqlFileOnServer);
            document.getElementById('fetchDatabasesButton').addEventListener('click', fetchDatabases);
            document.getElementById('fetchTablesButton').addEventListener('click', fetchTables);
            document.getElementById('runMigrationButton').addEventListener('click', runMigration);
            document.getElementById('loadMappingButton').addEventListener('click', loadSelectedMapping);
            document.getElementById('saveMappingButton').addEventListener('click', saveCurrentMapping);

            // AI Assistant Listeners
            document.getElementById('ai-assistant-button').addEventListener('click', () => {
                const modalOverlay = document.getElementById('ai-chat-modal-overlay');
                modalOverlay.classList.remove('hidden');
                setTimeout(() => modalOverlay.classList.add('visible'), 10);
            });
            document.getElementById('ai-chat-close').addEventListener('click', () => {
                const modalOverlay = document.getElementById('ai-chat-modal-overlay');
                modalOverlay.classList.remove('visible');
                setTimeout(() => modalOverlay.classList.add('hidden'), 300);
            });
            document.getElementById('ai-chat-send').addEventListener('click', () => sendChatMessage());
            document.getElementById('ai-chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            // Listener for error text selection
            document.body.addEventListener('click', (e) => {
                const askAiButton = document.getElementById('ask-ai-on-selection');
                if (askAiButton && e.target.id !== 'ask-ai-on-selection') {
                    askAiButton.remove();
                }
            });

            document.getElementById('status-area').addEventListener('mouseup', (e) => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                const askAiButton = document.getElementById('ask-ai-on-selection');
                if (askAiButton) askAiButton.remove();

                if (selectedText && e.target.closest('.error-details')) {
                    const newButton = document.createElement('button');
                    newButton.id = 'ask-ai-on-selection';
                    newButton.textContent = 'Ask AI about this error';
                    newButton.className = 'ask-ai-btn absolute bg-indigo-600 text-white px-2 py-1 rounded shadow-lg text-xs z-50';
                    document.body.appendChild(newButton);
                    newButton.style.left = `${e.pageX}px`;
                    newButton.style.top = `${e.pageY + 5}px`;
                    
                    const errorDetailsDiv = e.target.closest('.error-details');
                    const errorJson = errorDetailsDiv.dataset.errorJson;

                    newButton.onclick = () => {
                        askAiAboutError(JSON.parse(errorJson));
                        newButton.remove();
                    };
                }
            });
        });

        async function initializeStep1() {
            const selector = document.getElementById('sqlFileSelector');
            try {
                const response = await fetch(`${API_BASE_URL}/api/list_sql_files`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const files = await response.json();
                selector.innerHTML = '<option value="">-- Select a file --</option>';
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.textContent = file;
                    selector.appendChild(option);
                });
            } catch (error) {
                handleFetchError(error, "loading SQL file list");
                selector.innerHTML = '<option value="">-- Could not load files --</option>';
            }
            selector.innerHTML += '<option value="custom">-- Enter Full Path Manually --</option>';
            selector.onchange = () => {
                const customPathInput = document.getElementById('sqlFilePathInput');
                customPathInput.classList.toggle('hidden', selector.value !== 'custom');
            };
            loadSavedMappings(); 
        }

        // --- Status Update Function ---
        function showStatus(message, isError = false) {
            const statusArea = document.getElementById('status-area');
            statusArea.innerHTML = message;
            statusArea.className = 'mb-4 p-4 text-center rounded-md';
            statusArea.classList.add(isError ? 'bg-red-100' : 'bg-blue-100', isError ? 'text-red-700' : 'text-blue-700');
            statusArea.classList.remove('hidden');
        }

        function handleFetchError(error, context) {
            let errorMessage = `Error during ${context}: ${error.message}.`;
            if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                errorMessage += ' <b>Could not connect to the backend server.</b> Please ensure the app.py server is running in your terminal.';
            }
            showStatus(errorMessage, true);
        }

        // --- API Calls ---
        async function parseSqlFileOnServer() {
            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let payload = {};
            if (selector.value === 'custom') {
                if (!customPathInput.value) { alert("Please enter a custom file path."); return; }
                payload = { path: customPathInput.value };
            } else if (selector.value) {
                payload = { filename: selector.value };
            } else {
                alert("Please select a SQL file.");
                return;
            }
            showStatus("Parsing SQL file on server...", false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/parse_sql_file`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to parse file.');
                mysqlSchemaData = data;
                displayMysqlSchema();
                showStatus("SQL file parsed successfully. Please connect to PostgreSQL.", false);
                document.getElementById('step2').classList.remove('hidden');
            } catch (error) {
                handleFetchError(error, "parsing SQL file");
            }
        }

        async function fetchDatabases() {
            pgConnectionDetails = {
                host: document.getElementById('pgHost').value,
                port: document.getElementById('pgPort').value,
                user: document.getElementById('pgUser').value,
                password: document.getElementById('pgPassword').value
            };
            showStatus("Connecting to PostgreSQL...", false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/get_databases`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pgConnectionDetails)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to connect.');
                const selector = document.getElementById('dbSelector');
                selector.innerHTML = '';
                data.forEach(dbName => {
                    const option = document.createElement('option');
                    option.value = dbName;
                    option.textContent = dbName;
                    selector.appendChild(option);
                });
                showStatus("Successfully fetched databases. Please select one.", false);
                document.getElementById('step2b-db-select').classList.remove('hidden');
            } catch (error) {
                handleFetchError(error, "fetching databases");
            }
        }

        async function fetchTables() {
            const selectedDb = document.getElementById('dbSelector').value;
            if (!selectedDb) { alert("Please select a database first."); return; }
            pgConnectionDetails.dbname = selectedDb;
            showStatus(`Fetching tables from "${selectedDb}"...`, false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/get_tables`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ creds: pgConnectionDetails, dbname: selectedDb })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to fetch tables.');
                postgresSchemaData = data;
                displayPostgresSchema();
                showStatus("Successfully fetched tables. You may now map the columns.", false);
                document.getElementById('step3').classList.remove('hidden');
                document.getElementById('step3b-custom-commands').classList.remove('hidden');
                document.getElementById('step4').classList.remove('hidden');
            } catch(error) {
                handleFetchError(error, "fetching tables");
            }
        }

        async function runMigration() {
            if (Object.keys(mappingRules).length === 0) {
                alert("Please define at least one mapping rule before running the migration.");
                return;
            }
            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let filePath = selector.value === 'custom' ? customPathInput.value : selector.value;
            const migrationConfig = {
                pg_config: pgConnectionDetails,
                mapping_rules: mappingRules,
                mysql_dump_file_path: filePath,
                truncate_tables: document.getElementById('truncateCheckbox').checked,
                handle_conflicts: document.getElementById('upsertCheckbox').checked,
                filters: migrationFilters,
                pre_migration_commands: document.getElementById('pre-migration-commands').value,
                post_migration_commands: document.getElementById('post-migration-commands').value
            };
            showStatus("Migration started... This may take a while.", false);
            try {
                const response = await fetch(`${API_BASE_URL}/api/run_migration`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(migrationConfig)
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || "An unknown server error occurred.");
                let summaryHtml = `<h3 class="text-lg font-semibold mb-2">${result.message}</h3>`;
                summaryHtml += '<div class="text-left max-w-3xl mx-auto border rounded-lg bg-white">';
                if (Object.keys(result.summary).length === 0) {
                    summaryHtml += '<p class="p-4">No data was processed. Check if the source tables exist in the SQL file and are mapped correctly.</p>';
                }
                for (const table in result.summary) {
                    const stats = result.summary[table];
                    summaryHtml += `<div class="p-3 border-b last:border-b-0">`;
                    summaryHtml += `<p><strong>Table: ${table}</strong></p>`;
                    summaryHtml += `<p class="text-green-700">Rows Inserted: ${stats.inserted || 0}</p>`;
                    if (stats.updated > 0) {
                        summaryHtml += `<p class="text-blue-700">Rows Updated (Upsert): ${stats.updated}</p>`;
                    }
                    if (stats.filtered_out > 0) {
                        summaryHtml += `<p class="text-yellow-600">Rows Filtered Out (by WHERE clause): ${stats.filtered_out}</p>`;
                    }
                    if (stats.failed > 0) {
                        summaryHtml += `<p class="text-red-700">Rows Failed: ${stats.failed}</p>`;
                        if (stats.errors && stats.errors.length > 0) {
                            stats.errors.forEach((err, index) => {
                                const errorId = `${table}-error-${index}`;
                                const errorJson = escapeHtml(JSON.stringify(err));
                                summaryHtml += `
                                    <div class="error-details mt-2" data-error-json='${errorJson}'>
                                        <div><strong>Error:</strong> ${escapeHtml(err.error)} 
                                            <button class="ask-ai-btn" onclick='askAiAboutError(${errorJson})'>Ask AI</button>
                                        </div>
                                        <div class="mt-1"><strong>Query:</strong> <pre>${escapeHtml(err.query)}</pre></div>
                                        <div class="mt-1"><strong>Values:</strong> ${escapeHtml(JSON.stringify(err.values))}</div>
                                    </div>`;
                            });
                        }
                    }
                    summaryHtml += `</div>`;
                }
                summaryHtml += '</div>';

                const statusArea = document.getElementById('status-area');
                statusArea.innerHTML = summaryHtml;
                statusArea.className = 'mb-4 p-4 rounded-md bg-gray-100';
                statusArea.classList.remove('hidden');
            } catch (error) {
                handleFetchError(error, "running migration");
            }
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe === null || unsafe === undefined ? '' : String(unsafe);
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // --- UI Rendering & Filters ---
        function displayMysqlSchema() {
            const container = document.getElementById('mysqlSchema');
            container.innerHTML = '';
            createTableFilter('mysql-table-filter', mysqlSchemaData, updateSourceTableVisibility);
            for (const tableName in mysqlSchemaData) {
                const tableEl = createSchemaTableElement(tableName, mysqlSchemaData[tableName].columns, 'mysql');
                tableEl.style.display = 'block'; // Show tables by default
                container.appendChild(tableEl);
            }
        }

        function displayPostgresSchema() {
            const container = document.getElementById('postgresSchema');
            container.innerHTML = '';
            createTableFilter('pg-table-filter', postgresSchemaData, updateTargetTableVisibility);
            for (const tableName in postgresSchemaData) {
                const tableEl = createSchemaTableElement(tableName, postgresSchemaData[tableName].columns, 'pg');
                tableEl.style.display = 'block'; // Show tables by default
                container.appendChild(tableEl);
            }
        }

        function createTableFilter(containerId, tables, changeHandler) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            if (Object.keys(tables).length === 0) return;
            const dropdownContainer = document.createElement('div');
            dropdownContainer.className = 'relative';
            const dropdownButton = document.createElement('button');
            dropdownButton.type = 'button';
            dropdownButton.className = 'w-full text-left p-2 border border-gray-300 rounded-md bg-white flex justify-between items-center';
            dropdownButton.innerHTML = '<span>Select tables to display...</span><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>';
            const dropdownPanel = document.createElement('div');
            dropdownPanel.className = 'hidden absolute bg-white border mt-1 rounded-md shadow-lg z-20 w-full';
            const searchContainer = document.createElement('div');
            searchContainer.className = 'p-2 border-b';
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'Search tables...';
            searchInput.className = 'w-full p-1 border border-gray-300 rounded-md text-sm';
            searchContainer.appendChild(searchInput);
            dropdownPanel.appendChild(searchContainer);
            const listContainer = document.createElement('div');
            listContainer.className = 'table-filter-panel-content';
            Object.keys(tables).sort().forEach(tableName => {
                const label = document.createElement('label');
                label.className = 'flex items-center p-2 hover:bg-gray-100 cursor-pointer text-sm';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'mr-2';
                checkbox.value = tableName;
                checkbox.checked = false; 
                checkbox.addEventListener('change', changeHandler);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(tableName));
                listContainer.appendChild(label);
            });
            dropdownPanel.appendChild(listContainer);
            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.toLowerCase();
                listContainer.querySelectorAll('label').forEach(label => {
                    const tableName = label.textContent.toLowerCase();
                    label.style.display = tableName.includes(searchTerm) ? 'flex' : 'none';
                });
            });
            dropdownButton.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdownPanel.classList.toggle('hidden');
            });
            document.body.addEventListener('click', () => dropdownPanel.classList.add('hidden'));
            dropdownPanel.addEventListener('click', (e) => e.stopPropagation());
            dropdownContainer.appendChild(dropdownButton);
            dropdownContainer.appendChild(dropdownPanel);
            container.appendChild(dropdownContainer);
        }

        function updateSourceTableVisibility() {
            const filterContainer = document.getElementById('mysql-table-filter');
            const checkboxes = filterContainer.querySelectorAll('input[type="checkbox"]');
            const selectedTables = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            for (const tableName in mysqlSchemaData) {
                const tableEl = document.getElementById(`mysql-table-${tableName}`);
                if (tableEl) tableEl.style.display = selectedTables.includes(tableName) ? 'block' : 'none';
            }
            drawMappingLines();
        }

        function updateTargetTableVisibility() {
            const filterContainer = document.getElementById('pg-table-filter');
            const checkboxes = filterContainer.querySelectorAll('input[type="checkbox"]');
            const selectedTables = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            for (const tableName in postgresSchemaData) {
                const tableEl = document.getElementById(`pg-table-${tableName}`);
                if (tableEl) tableEl.style.display = selectedTables.includes(tableName) ? 'block' : 'none';
            }
            drawMappingLines();
        }

        function createSchemaTableElement(tableName, columns, type) {
            const tableDiv = document.createElement('div');
            tableDiv.id = `${type}-table-${tableName}`;
            tableDiv.className = 'p-4 border border-gray-200 rounded-lg bg-gray-50';
            tableDiv.style.display = 'none';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center';
            headerDiv.innerHTML = `<h4 class="font-bold text-lg">${tableName}</h4>`;

            if (type === 'mysql') {
                const btnGroup = document.createElement('div');
                btnGroup.className = 'flex items-center space-x-2';
                
                const viewBtn = document.createElement('button');
                viewBtn.type = 'button';
                viewBtn.innerHTML = `<svg class="w-5 h-5 text-gray-500 hover:text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>`;
                viewBtn.onclick = () => viewSourceTable(tableName);
                viewBtn.title = "View Full Table Data";
                btnGroup.appendChild(viewBtn);

                const settingsBtn = document.createElement('button');
                settingsBtn.type = 'button';
                settingsBtn.innerHTML = `<svg class="w-5 h-5 text-gray-500 hover:text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>`;
                settingsBtn.onclick = () => openSettingsModal(tableName);
                settingsBtn.title = "Table Settings (Sort, Filter, Replace)";
                btnGroup.appendChild(settingsBtn);

                headerDiv.appendChild(btnGroup);
            }
            tableDiv.appendChild(headerDiv);

            const colsList = document.createElement('div');
            colsList.className = 'mt-2 space-y-2';
            columns.forEach(col => {
                const colItem = document.createElement('div');
                colItem.className = 'column-item p-2 border border-gray-200 rounded-md cursor-pointer bg-white';
                const mainContent = document.createElement('div');
                mainContent.className = 'flex justify-between items-center';
                const nameAndType = document.createElement('div');
                nameAndType.className = 'flex items-center';

                if (type === 'pg') {
                    colItem.id = `pg-${tableName}-${col.name}`;
                    const nullableBadge = col.is_nullable === 'NO' ? '<span class="not-null-badge">NOT NULL</span>' : '';
                    nameAndType.innerHTML = `<span>${col.name}</span> <span class="data-type">(${col.type})</span>${nullableBadge}`;
                    colItem.dataset.colName = col.name;
                    colItem.dataset.tableName = tableName;
                    colItem.onclick = () => openMappingPanel(tableName, col);
                    colItem.addEventListener('dragover', handleDragOver);
                    colItem.addEventListener('drop', handleDrop);
                } else {
                    colItem.id = `mysql-${tableName}-${col.name}`;
                    nameAndType.innerHTML = `
                        <span>${col.name}</span>
                        <span class="data-type">(${col.type})</span>
                        <button type="button" onclick="event.stopPropagation(); viewColumnData('${tableName}', '${col.name}')" class="ml-2 text-gray-400 hover:text-blue-600" title="Preview Unique Column Values">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                        </button>
                    `;
                    colItem.draggable = true;
                    colItem.addEventListener('dragstart', handleDragStart);
                    colItem.addEventListener('dblclick', handleSourceColumnDoubleClick);
                }

                mainContent.appendChild(nameAndType);
                colItem.appendChild(mainContent);
                colsList.appendChild(colItem);
            });
            tableDiv.appendChild(colsList);
            return tableDiv;
        }

        // --- Drag & Drop ---
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.currentTarget.id);
            e.currentTarget.classList.add('dragging');
        }
        document.addEventListener('dragend', () => document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging')));

        function handleDragOver(e) { e.preventDefault(); }

        function handleDrop(e) {
            e.preventDefault();
            const targetEl = e.target.closest('.column-item[data-col-name]');
            if (!targetEl) return;
            const sourceId = e.dataTransfer.getData('text/plain');
            const [, mysqlTable, mysqlCol] = sourceId.split('-');
            const pgTable = targetEl.dataset.tableName;
            const pgCol = targetEl.dataset.colName;

            if (!mappingRules[pgTable]) mappingRules[pgTable] = {};
            mappingRules[pgTable][pgCol] = { type: 'direct', value: mysqlCol, source_table: mysqlTable };
            
            document.querySelector(`#mysql-table-filter input[value="${mysqlTable}"]`).checked = true;
            document.querySelector(`#pg-table-filter input[value="${pgTable}"]`).checked = true;
            updateSourceTableVisibility();
            updateTargetTableVisibility();

            setTimeout(updateColumnUIs, 50); // Timeout to allow DOM update
        }

        function handleSourceColumnDoubleClick(e) {
            const sourceEl = e.currentTarget;
            if (!sourceEl || !sourceEl.id) return;
            const [, mysqlTable, mysqlCol] = sourceEl.id.split('-');
            if (!mysqlTable || !mysqlCol) return;

            for (const pgTable in mappingRules) {
                for (const pgCol in mappingRules[pgTable]) {
                    const rule = mappingRules[pgTable][pgCol];
                    if ((rule.type === 'direct' && rule.source_table === mysqlTable && rule.value === mysqlCol) ||
                        (rule.type === 'transformation' && rule.source_table === mysqlTable && rule.params.columns.includes(mysqlCol))) {
                        delete mappingRules[pgTable][pgCol];
                    }
                }
                if (Object.keys(mappingRules[pgTable]).length === 0) {
                    delete mappingRules[pgTable];
                }
            }
            updateColumnUIs();
        }

        // --- UI & State Update Helpers ---
        function findSourceTablesForTarget(pgTable) {
            const sourceTables = new Set();
            const rules = mappingRules[pgTable] || {};
            for (const col in rules) {
                const rule = rules[col];
                if (rule.source_table) {
                    sourceTables.add(rule.source_table);
                }
                if (rule.type === 'transformation' && rule.params && rule.params.parts) {
                    rule.params.parts.forEach(part => {
                        if (part.type === 'column' && rule.source_table) {
                             sourceTables.add(rule.source_table);
                        }
                    });
                }
            }
            return Array.from(sourceTables);
        }

        function updateColumnUIs() {
            document.querySelectorAll('.mapping-info-badge').forEach(b => b.remove());
            document.querySelectorAll('.mapped, .mapped-target').forEach(el => el.classList.remove('mapped', 'mapped-target'));
            
            for(const pgTable in mappingRules) {
                for(const pgCol in mappingRules[pgTable]) {
                    const rule = mappingRules[pgTable][pgCol];
                    const targetEl = document.getElementById(`pg-${pgTable}-${pgCol}`);
                    if (!targetEl) continue;

                    let badgeText = `[${rule.type.toUpperCase()}]`;
                    if(rule.type === 'direct') {
                        badgeText = `[${rule.source_table}.${rule.value}]`;
                        const sourceEl = document.getElementById(`mysql-${rule.source_table}-${rule.value}`);
                        if(sourceEl) sourceEl.classList.add('mapped');
                    } else if(rule.type === 'static') {
                        badgeText = `[STATIC: ${rule.value}]`;
                    } else if (rule.type === 'auto-increment') {
                        badgeText = `[AUTO-INC]`;
                    } else if (rule.type === 'transformation') {
                        badgeText = `[${rule.function}]`;
                        if (rule.params && rule.params.parts) {
                            rule.params.parts.forEach(part => {
                                if (part.type === 'column') {
                                    const sourceEl = document.getElementById(`mysql-${rule.source_table}-${part.value}`);
                                    if(sourceEl) sourceEl.classList.add('mapped');
                                }
                            });
                        }
                    } else if (rule.type === 'lookup' || rule.type === 'target_lookup' || rule.type === 'basic_target_lookup') {
                        badgeText = rule.type.includes('target') ? `[T-LOOKUP]` : `[S-LOOKUP]`;
                        const sourceTables = findSourceTablesForTarget(pgTable).length > 0 ? findSourceTablesForTarget(pgTable) : Object.keys(mysqlSchemaData);
                        sourceTables.forEach(tableName => {
                            const sourceEl = document.getElementById(`mysql-${tableName}-${rule.match_col}`);
                            if (sourceEl) sourceEl.classList.add('mapped');
                        });
                    } else if (rule.type === 'group_and_aggregate') {
                        badgeText = `[AGG]`;
                        const sourceEl = document.getElementById(`mysql-${rule.source_table}-${rule.group_by_column}`);
                        if (sourceEl) sourceEl.classList.add('mapped');
                        const sourceEl2 = document.getElementById(`mysql-${rule.source_table}-${rule.aggregate_column}`);
                        if (sourceEl2) sourceEl2.classList.add('mapped');
                    }

                    if (rule.post_transform) {
                        if (rule.post_transform.date_format && rule.post_transform.date_format.from) {
                            badgeText += ' [DATE]';
                        }
                        if (rule.post_transform.cast_to) {
                            badgeText += ` [${rule.post_transform.cast_to.toUpperCase()}]`;
                        }
                    }

                    const badge = document.createElement('span');
                    badge.className = 'mapping-info-badge';
                    badge.textContent = badgeText;
                    badge.title = JSON.stringify(rule, null, 2);
                    targetEl.querySelector('.flex').appendChild(badge);
                    targetEl.classList.add('mapped-target');
                }
            }
            drawMappingLines();
        }

        function drawMappingLines() {
            const svg = document.getElementById('mapping-svg');
            svg.innerHTML = svg.querySelector('defs').outerHTML; // Clear previous lines
            const containerRect = document.getElementById('mapping-container').getBoundingClientRect();

            for(const pgTable in mappingRules) {
                for(const pgCol in mappingRules[pgTable]) {
                    const rule = mappingRules[pgTable][pgCol];
                    const targetEl = document.getElementById(`pg-${pgTable}-${pgCol}`);
                    if (!targetEl || targetEl.offsetParent === null) continue;

                    const drawLineFromSource = (sourceEl) => {
                        if (sourceEl && sourceEl.offsetParent !== null) {
                            const sourceRect = sourceEl.getBoundingClientRect();
                            const targetRect = targetEl.getBoundingClientRect();
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', sourceRect.right - containerRect.left);
                            line.setAttribute('y1', sourceRect.top + sourceRect.height / 2 - containerRect.top);
                            line.setAttribute('x2', targetRect.left - containerRect.left);
                            line.setAttribute('y2', targetRect.top + targetRect.height / 2 - containerRect.top);
                            line.classList.add('mapped-line');
                            svg.appendChild(line);
                        }
                    };

                    if (rule.type === 'direct') {
                        drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${rule.value}`));
                    } else if (rule.type === 'transformation' && rule.params && rule.params.parts) {
                         rule.params.parts.forEach(part => {
                            if (part.type === 'column') {
                                drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${part.value}`));
                            }
                        });
                    } else if (rule.type === 'lookup' || rule.type === 'target_lookup' || rule.type === 'basic_target_lookup') {
                        const sourceTables = findSourceTablesForTarget(pgTable).length > 0 ? findSourceTablesForTarget(pgTable) : Object.keys(mysqlSchemaData);
                        sourceTables.forEach(tableName => {
                            drawLineFromSource(document.getElementById(`mysql-${tableName}-${rule.match_col}`));
                        });
                    } else if (rule.type === 'group_and_aggregate') {
                        drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${rule.group_by_column}`));
                        drawLineFromSource(document.getElementById(`mysql-${rule.source_table}-${rule.aggregate_column}`));
                    }
                }
            }
        }
        window.addEventListener('resize', drawMappingLines);

        // --- Modals & Panels ---
        function openMappingPanel(pgTable, pgCol) {
            const modal = document.getElementById('mapping-panel-modal');
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('visible'), 10);
            const content = document.getElementById('mapping-panel-content');
            const currentRule = mappingRules[pgTable]?.[pgCol.name] || {};
            let html = `<h2 class="text-2xl font-bold mb-4">Set Mapping for ${pgTable}.${pgCol.name}</h2>`;
            html += `
                <div class="mb-4">
                    <label class="block font-semibold mb-1">Mapping Type</label>
                    <select id="mapping-type-selector" class="w-full p-2 border border-gray-300 rounded-md">
                        <option value="none">-- None --</option>
                        <option value="direct">Direct Mapping (from Source)</option>
                        <option value="transformation">Transformation (e.g., CONCAT)</option>
                        <option value="group_and_aggregate">Group and Aggregate to Array</option>
                        <option value="lookup">Lookup from another Source Table</option>
                        <option value="target_lookup">Lookup from Target DB Table</option>
                        <option value="basic_target_lookup">Basic Target Lookup (Direct Query)</option>
                        <option value="static">Static Value</option>
                        <option value="auto-increment">Auto-Increment</option>
                    </select>
                </div>
                <div id="mapping-options" class="space-y-4 border-t pt-4"></div>
                
                <!-- Post-Processing Transformations -->
                <div id="post-processing-container" class="mt-6 border-t pt-4">
                    <h3 class="font-semibold text-lg mb-2">Post-Processing</h3>
                    <p class="text-sm text-gray-600 mb-3">Apply transformations after the main value is determined.</p>
                    <div class="space-y-4">
                        <div>
                            <label class="block font-semibold text-sm mb-1">Change Data Type (Cast)</label>
                            <select id="post-transform-cast" class="w-full p-2 border border-gray-300 rounded-md">
                                <option value="">-- Don't Change --</option>
                                <option value="string">String</option>
                                <option value="integer">Integer</option>
                                <option value="float">Float</option>
                                <option value="boolean">Boolean</option>
                            </select>
                        </div>
                        <div>
                            <label class="block font-semibold text-sm mb-1">Re-format Date</label>
                            <div class="grid grid-cols-2 gap-2">
                                <input type="text" id="post-transform-date-from" class="w-full p-2 border border-gray-300 rounded-md" placeholder="Source Format (e.g., %Y-%m-%d)">
                                <input type="text" id="post-transform-date-to" class="w-full p-2 border border-gray-300 rounded-md" placeholder="Target Format (e.g., %d %B %Y)">
                            </div>
                             <p class="text-xs text-gray-500 mt-1">Uses Python strptime/strftime format codes. Leave blank to disable.</p>
                        </div>
                    </div>
                </div>

                <!-- Fallback Options -->
                <div id="fallback-container" class="mt-6 border-t pt-4">
                    <h3 class="font-semibold text-lg mb-2">Fallback for Empty/Null Values</h3>
                    <p class="text-sm text-gray-600 mb-3">If the mapping result is empty or NULL, use this fallback. This is ignored for Static and Auto-Increment mapping types.</p>
                    <div class="flex items-center mb-3">
                        <input type="checkbox" id="fallback-enabled-checkbox" class="h-4 w-4">
                        <label for="fallback-enabled-checkbox" class="ml-2">Enable Fallback</label>
                    </div>
                    <div id="fallback-options-container" class="hidden space-y-4">
                        <select id="fallback-type-selector" class="w-full p-2 border border-gray-300 rounded-md">
                            <option value="static">Static Value</option>
                            <option value="auto-increment">Auto-Increment</option>
                            <option value="set_null">Set NULL</option>
                        </select>
                        <div id="fallback-options"></div>
                    </div>
                </div>
                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" onclick="closeMappingPanelModal()" class="btn btn-tertiary">Cancel</button>
                    <button type="button" onclick="saveMappingRule('${pgTable}', '${pgCol.name}')" class="btn btn-primary">Save Mapping</button>
                </div>
            `;
            content.innerHTML = html;

            const typeSelector = document.getElementById('mapping-type-selector');
            const fallbackEnabledCheckbox = document.getElementById('fallback-enabled-checkbox');
            const fallbackContainer = document.getElementById('fallback-options-container');
            const fallbackTypeSelector = document.getElementById('fallback-type-selector');

            typeSelector.onchange = () => {
                const type = typeSelector.value;
                const isFallbackDisabled = ['static', 'auto-increment', 'none'].includes(type);
                const isPostProcessingDisabled = ['group_and_aggregate', 'none'].includes(type);
                
                document.getElementById('fallback-container').style.display = isFallbackDisabled ? 'none' : 'block';
                document.getElementById('post-processing-container').style.display = isPostProcessingDisabled ? 'none' : 'block';

                renderMappingOptions(pgTable, pgCol.name);
            };
            fallbackEnabledCheckbox.onchange = () => {
                fallbackContainer.classList.toggle('hidden', !fallbackEnabledCheckbox.checked);
            };
            fallbackTypeSelector.onchange = () => renderFallbackOptions(currentRule.on_null);

            if (currentRule.type) {
                typeSelector.value = currentRule.type;
            }
            if(currentRule.on_null) {
                fallbackEnabledCheckbox.checked = true;
                fallbackContainer.classList.remove('hidden');
                fallbackTypeSelector.value = currentRule.on_null.type;
            }
            if (currentRule.post_transform) {
                const castSelect = document.getElementById('post-transform-cast');
                const dateFromInput = document.getElementById('post-transform-date-from');
                const dateToInput = document.getElementById('post-transform-date-to');
                if (currentRule.post_transform.cast_to) {
                    castSelect.value = currentRule.post_transform.cast_to;
                }
                if (currentRule.post_transform.date_format) {
                    dateFromInput.value = currentRule.post_transform.date_format.from || '';
                    dateToInput.value = currentRule.post_transform.date_format.to || '';
                }
            }

            typeSelector.dispatchEvent(new Event('change'));
            renderFallbackOptions(currentRule.on_null);
        }

        function renderMappingOptions(pgTable, pgCol) {
            const container = document.getElementById('mapping-options');
            const type = document.getElementById('mapping-type-selector').value;
            const currentRule = mappingRules[pgTable]?.[pgCol] || {};
            let html = '';

            const createSelect = (id, label, options) => `<div><label class="block font-semibold text-sm mb-1">${label}</label><select id="${id}" class="w-full p-2 border border-gray-300 rounded-md">${options}</select></div>`;
            const createInput = (id, label, value, type='text') => `<div><label class="block font-semibold text-sm mb-1">${label}</label><input type="${type}" id="${id}" class="w-full p-2 border border-gray-300 rounded-md" value="${escapeHtml(value)}"></div>`;

            if (type === 'direct') {
                let allSourceCols = '';
                Object.keys(mysqlSchemaData).sort().forEach(t => {
                    mysqlSchemaData[t].columns.forEach(c => {
                        allSourceCols += `<option value="${c.name}" data-table="${t}">${t}.${c.name}</option>`
                    })
                });
                html = createSelect('direct-source-col', 'Source Column', allSourceCols);
            } else if (type === 'static') {
                html = createInput('static-value', 'Static Value', currentRule.value || '');
            } else if (type === 'auto-increment') {
                html = createInput('auto-inc-start', 'Start Number', currentRule.start || 1, 'number');
                html += createInput('auto-inc-step', 'Step', currentRule.step || 1, 'number');
            } else if (type === 'lookup' || type === 'target_lookup' || type === 'basic_target_lookup') {
                const isTargetLookup = type === 'target_lookup' || type === 'basic_target_lookup';
                const lookupSchema = isTargetLookup ? postgresSchemaData : mysqlSchemaData;
                const lookupTableOptions = Object.keys(lookupSchema).sort().map(t => `<option value="${t}">${t}</option>`).join('');
                const lookupLabel = isTargetLookup ? 'Target (PostgreSQL)' : 'Source (MySQL)';

                let matchColOptions = '';
                const sourceTablesInvolved = findSourceTablesForTarget(pgTable).length > 0 ? findSourceTablesForTarget(pgTable) : Object.keys(mysqlSchemaData);
                const uniqueColNames = new Set();
                sourceTablesInvolved.forEach(tableName => {
                    mysqlSchemaData[tableName]?.columns.forEach(col => uniqueColNames.add(col.name));
                });
                Array.from(uniqueColNames).sort().forEach(colName => {
                    matchColOptions += `<option value="${colName}">${colName}</option>`;
                });

                if (type === 'basic_target_lookup') {
                         html = `
                            <p class="text-sm font-bold text-gray-700">This performs a direct query on the target DB for each row. Use with caution.</p>
                            ${createSelect('lookup-table', 'Lookup From PG Table', lookupTableOptions)}
                            ${createSelect('lookup-get-col', 'Get this column', '')}
                            ${createSelect('lookup-match-col', 'Match using this column from the source row.', matchColOptions)}
                            ${createInput('where-clause-input', 'WHERE Clause (use {value} for placeholder)', currentRule.where_clause || '')}
                            ${createInput('order-by-clause-input', 'ORDER BY Clause (optional)', currentRule.order_by_clause || '')}
                            ${createInput('lookup-default-val', 'Default value if not found (optional)', currentRule.default || '')}
                        `;
                } else {
                        html = `
                            <p class="text-sm font-bold text-gray-700">1. Find a row in another ${lookupLabel} table...</p>
                            ${createSelect('lookup-table', `Lookup From ${lookupLabel} Table`, lookupTableOptions)}
                            ${createSelect('lookup-where-col', '...where this column...', '')}
                            <p class="text-sm font-bold text-gray-700 mt-2">2. ...matches a value from the current source row.</p>
                            ${createSelect('lookup-match-col', '...using this column from the source row.', matchColOptions)}
                            <p class="text-sm font-bold text-gray-700 mt-2">3. Then get the result.</p>
                            ${createSelect('lookup-get-col', 'Get value from this column in the found row', '')}
                            ${createInput('lookup-default-val', 'Default value if not found (optional)', currentRule.default || '')}
                        `;
                }
            } else if (type === 'transformation') {
                const tableOptions = Object.keys(mysqlSchemaData).sort().map(t => `<option value="${t}">${t}</option>`).join('');
                html = createSelect('transform-source-table', 'Source Table for Transformation', tableOptions);
                html += createSelect('transform-function', 'Function', '<option value="CONCAT">CONCAT</option>');
                html += `<div id="transform-params" class="p-2 border border-gray-200 rounded-md bg-gray-50 space-y-2 mt-2"></div>`;
            } else if (type === 'group_and_aggregate') {
                const tableOptions = Object.keys(mysqlSchemaData).sort().map(t => `<option value="${t}">${t}</option>`).join('');
                html = createSelect('aggregate-source-table', 'Source Table for Aggregation', tableOptions);
                html += `<div id="aggregate-cols-container" class="space-y-2 mt-2"></div>`;
            }
            container.innerHTML = html;

            if (type === 'direct' && currentRule.value) {
                const colSelect = document.getElementById('direct-source-col');
                const optionToSelect = colSelect.querySelector(`option[value="${currentRule.value}"][data-table="${currentRule.source_table}"]`);
                if(optionToSelect) optionToSelect.selected = true;
            } else if (type === 'lookup' || type === 'target_lookup' || type === 'basic_target_lookup') {
                const isTargetLookup = type === 'target_lookup' || type === 'basic_target_lookup';
                const lookupSchema = isTargetLookup ? postgresSchemaData : mysqlSchemaData;
                const lookupTableSelect = document.getElementById('lookup-table');
                const getColSelect = document.getElementById('lookup-get-col');
                const whereColSelect = document.getElementById('lookup-where-col');
                const matchColSelect = document.getElementById('lookup-match-col');

                const updateLookupCols = () => {
                    const selectedTable = lookupTableSelect.value;
                    const cols = lookupSchema[selectedTable]?.columns || [];
                    const options = cols.map(c => `<option value="${c.name}">${c.name}</option>`).join('');
                    if(getColSelect) getColSelect.innerHTML = options;
                    if(whereColSelect) whereColSelect.innerHTML = options;
                };

                lookupTableSelect.onchange = updateLookupCols;
                if(currentRule.lookup_table || currentRule.lookup_source_table) lookupTableSelect.value = currentRule.lookup_table || currentRule.lookup_source_table;
                updateLookupCols();
                
                if(currentRule.get_col) getColSelect.value = currentRule.get_col;
                if(currentRule.where_col) whereColSelect.value = currentRule.where_col;
                if(currentRule.match_col) matchColSelect.value = currentRule.match_col;
            } else if (type === 'transformation') {
                const tableSelect = document.getElementById('transform-source-table');
                const functionSelect = document.getElementById('transform-function');
                const renderTransformParams = () => {
                    const paramsContainer = document.getElementById('transform-params');
                    if (functionSelect.value === 'CONCAT') {
                        paramsContainer.innerHTML = `
                            <p class="text-sm font-medium">CONCAT Builder</p>
                            <div id="concat-parts-container" class="space-y-2"></div>
                            <button type="button" onclick="addConcatPart()" class="text-xs text-blue-600 hover:underline">+ Add Part</button>
                        `;
                        const parts = currentRule.params?.parts || [
                            { type: 'column', value: '' }, 
                            { type: 'separator', value: ' ' }, 
                            { type: 'column', value: '' }
                        ];
                        renderConcatParts(parts);
                    }
                };
                tableSelect.onchange = renderTransformParams;
                functionSelect.onchange = renderTransformParams;
                if(currentRule.source_table) tableSelect.value = currentRule.source_table;
                renderTransformParams();
            } else if (type === 'group_and_aggregate') {
                const tableSelect = document.getElementById('aggregate-source-table');
                const renderAggregateParams = () => {
                    const paramsContainer = document.getElementById('aggregate-cols-container');
                    const colOptions = mysqlSchemaData[tableSelect.value].columns.map(c => `<option value="${c.name}">${c.name}</option>`).join('');
                    paramsContainer.innerHTML = `
                        ${createSelect('aggregate-group-by-col', 'Group By This Column', colOptions)}
                        ${createSelect('aggregate-aggregate-col', 'Collect Values From This Column', colOptions)}
                    `;
                    if (currentRule.group_by_column) {
                        document.getElementById('aggregate-group-by-col').value = currentRule.group_by_column;
                    }
                    if (currentRule.aggregate_column) {
                        document.getElementById('aggregate-aggregate-col').value = currentRule.aggregate_column;
                    }
                };
                tableSelect.onchange = renderAggregateParams;
                if (currentRule.source_table) {
                    tableSelect.value = currentRule.source_table;
                }
                renderAggregateParams();
            }
        }
        
        // --- CONCAT Builder Functions ---
        function renderConcatParts(parts) {
            const container = document.getElementById('concat-parts-container');
            container.innerHTML = ''; // Clear existing
            const sourceTable = document.getElementById('transform-source-table').value;
            const colOptions = mysqlSchemaData[sourceTable]?.columns.map(c => `<option value="${c.name}">${c.name}</option>`).join('') || '';

            parts.forEach((part, index) => {
                const partDiv = document.createElement('div');
                partDiv.className = 'flex items-center space-x-2 p-2 border border-gray-200 rounded-md bg-white';
                partDiv.dataset.index = index;

                let partHtml = `
                    <select class="p-1 border border-gray-300 rounded-md text-sm part-type-select" onchange="handleConcatPartTypeChange(this)">
                        <option value="column" ${part.type === 'column' ? 'selected' : ''}>Column</option>
                        <option value="static" ${part.type === 'static' ? 'selected' : ''}>Static Text</option>
                        <option value="separator" ${part.type === 'separator' ? 'selected' : ''}>Separator</option>
                        <option value="auto-increment" ${part.type === 'auto-increment' ? 'selected' : ''}>Auto-Increment</option>
                    </select>
                    <div class="part-value-container flex-grow"></div>
                    <button type="button" onclick="removeConcatPart(this)" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
                `;
                partDiv.innerHTML = partHtml;
                container.appendChild(partDiv);
                
                const valueContainer = partDiv.querySelector('.part-value-container');
                renderConcatPartValueInput(valueContainer, part, colOptions);
            });
        }

        function renderConcatPartValueInput(container, part, colOptions) {
            let inputHtml = '';
            switch(part.type) {
                case 'column':
                    inputHtml = `<select class="w-full p-1 border border-gray-300 rounded-md text-sm part-value">${colOptions}</select>`;
                    break;
                case 'static':
                case 'separator':
                    inputHtml = `<input type="text" class="w-full p-1 border border-gray-300 rounded-md text-sm part-value" placeholder="Enter text" value="${escapeHtml(part.value || '')}">`;
                    break;
                case 'auto-increment':
                    inputHtml = `
                        <div class="flex space-x-1 text-sm">
                            <input type="text" class="w-1/2 p-1 border border-gray-300 rounded-md part-value" placeholder="Counter Name (unique)" value="${escapeHtml(part.key || '')}">
                            <input type="number" class="w-1/4 p-1 border border-gray-300 rounded-md part-start" placeholder="Start" value="${escapeHtml(part.start || 1)}">
                            <input type="number" class="w-1/4 p-1 border border-gray-300 rounded-md part-step" placeholder="Step" value="${escapeHtml(part.step || 1)}">
                        </div>`;
                    break;
            }
            container.innerHTML = inputHtml;

            if (part.type === 'column' && part.value) {
                container.querySelector('.part-value').value = part.value;
            }
        }

        function handleConcatPartTypeChange(selectElement) {
            const partDiv = selectElement.closest('.flex');
            const valueContainer = partDiv.querySelector('.part-value-container');
            const sourceTable = document.getElementById('transform-source-table').value;
            const colOptions = mysqlSchemaData[sourceTable]?.columns.map(c => `<option value="${c.name}">${c.name}</option>`).join('') || '';
            renderConcatPartValueInput(valueContainer, { type: selectElement.value }, colOptions);
        }

        function addConcatPart() {
            const parts = readConcatPartsFromUI();
            parts.push({ type: 'separator', value: ' ' });
            renderConcatParts(parts);
        }

        function removeConcatPart(buttonElement) {
            const partDiv = buttonElement.closest('.flex');
            const index = parseInt(partDiv.dataset.index, 10);
            const parts = readConcatPartsFromUI();
            parts.splice(index, 1);
            renderConcatParts(parts);
        }

        function readConcatPartsFromUI() {
            const parts = [];
            document.querySelectorAll('#concat-parts-container > div').forEach(partDiv => {
                const type = partDiv.querySelector('.part-type-select').value;
                const newPart = { type };
                if (type === 'column') {
                    newPart.value = partDiv.querySelector('.part-value').value;
                } else if (type === 'static' || type === 'separator') {
                    newPart.value = partDiv.querySelector('.part-value').value;
                } else if (type === 'auto-increment') {
                    newPart.key = partDiv.querySelector('.part-value').value;
                    newPart.start = parseInt(partDiv.querySelector('.part-start').value, 10) || 1;
                    newPart.step = parseInt(partDiv.querySelector('.part-step').value, 10) || 1;
                }
                parts.push(newPart);
            });
            return parts;
        }


        function renderFallbackOptions(currentFallbackRule = {}) {
            const container = document.getElementById('fallback-options');
            const type = document.getElementById('fallback-type-selector').value;
            let html = '';
            const createInput = (id, label, value, type='text') => `<div><label class="block font-semibold text-sm mb-1">${label}</label><input type="${type}" id="${id}" class="w-full p-2 border border-gray-300 rounded-md" value="${escapeHtml(value)}"></div>`;

            if (type === 'static') {
                html = createInput('fallback-static-value', 'Fallback Static Value', currentFallbackRule.value || '');
            } else if (type === 'auto-increment') {
                html = createInput('fallback-auto-inc-start', 'Start Number', currentFallbackRule.start || 1, 'number');
                html += createInput('fallback-auto-inc-step', 'Step', currentFallbackRule.step || 1, 'number');
            } else if (type === 'set_null') {
                html = `<p class="text-sm text-gray-500 p-2">The final value will be set to NULL if the mapping returns an empty result.</p>`;
            }
            container.innerHTML = html;
        }

        function convertRoleToInt(roleString) {
            const roleMap = {
                'admin': 1,
                'teacher': 2,
                'student': 3
            };
            return roleMap[String(roleString).toLowerCase()] || roleString;
        }

        function saveMappingRule(pgTable, pgCol) {
            if (!mappingRules[pgTable]) mappingRules[pgTable] = {};
            const type = document.getElementById('mapping-type-selector').value;
            if (type === 'none') {
                delete mappingRules[pgTable][pgCol];
                if (Object.keys(mappingRules[pgTable]).length === 0) {
                    delete mappingRules[pgTable];
                }
            } else {
                let newRule = { type };
                
                const isRoleIdColumn = pgCol.toLowerCase() === 'role_id';
                
                if (type === 'direct') {
                    const selectedOption = document.getElementById('direct-source-col').selectedOptions[0];
                    newRule.value = selectedOption.value;
                    newRule.source_table = selectedOption.dataset.table;
                } else if (type === 'static') {
                    const staticValue = document.getElementById('static-value').value;
                    newRule.value = isRoleIdColumn ? convertRoleToInt(staticValue) : staticValue;
                } else if (type === 'auto-increment') {
                    newRule.start = parseInt(document.getElementById('auto-inc-start').value);
                    newRule.step = parseInt(document.getElementById('auto-inc-step').value);
                } else if (type === 'transformation') {
                    newRule.source_table = document.getElementById('transform-source-table').value;
                    newRule.function = document.getElementById('transform-function').value;
                    if (newRule.function === 'CONCAT') {
                        newRule.params = { parts: readConcatPartsFromUI() };
                    }
                } else if (type === 'group_and_aggregate') {
                    newRule.source_table = document.getElementById('aggregate-source-table').value;
                    newRule.group_by_column = document.getElementById('aggregate-group-by-col').value;
                    newRule.aggregate_column = document.getElementById('aggregate-aggregate-col').value;
                } else if (type === 'lookup' || type === 'target_lookup' || type === 'basic_target_lookup') {
                    if (type === 'lookup') newRule.lookup_source_table = document.getElementById('lookup-table').value;
                    else newRule.lookup_table = document.getElementById('lookup-table').value;
                    
                    newRule.get_col = document.getElementById('lookup-get-col').value;
                    newRule.match_col = document.getElementById('lookup-match-col').value;
                    newRule.default = document.getElementById('lookup-default-val').value;

                    if(type !== 'basic_target_lookup') newRule.where_col = document.getElementById('lookup-where-col').value;
                    else {
                        newRule.where_clause = document.getElementById('where-clause-input').value;
                        newRule.order_by_clause = document.getElementById('order-by-clause-input').value;
                    }

                    if (isRoleIdColumn && newRule.default) {
                        newRule.default = convertRoleToInt(newRule.default);
                    }
                }

                // --- Save Post-Processing and Fallback Rules ---
                const postTransform = {};
                const castTo = document.getElementById('post-transform-cast').value;
                const dateFrom = document.getElementById('post-transform-date-from').value;
                const dateTo = document.getElementById('post-transform-date-to').value;

                if (castTo) {
                    postTransform.cast_to = castTo;
                }
                if (dateFrom && dateTo) {
                    postTransform.date_format = { from: dateFrom, to: dateTo };
                }
                if (Object.keys(postTransform).length > 0) {
                    newRule.post_transform = postTransform;
                }


                if (document.getElementById('fallback-enabled-checkbox').checked && !['static', 'auto-increment'].includes(type)) {
                    const fallbackType = document.getElementById('fallback-type-selector').value;
                    let fallbackRule = { type: fallbackType };
                    if (fallbackType === 'static') {
                        let fallbackValue = document.getElementById('fallback-static-value').value;
                        fallbackRule.value = isRoleIdColumn ? convertRoleToInt(fallbackValue) : fallbackValue;
                    } else if (fallbackType === 'auto-increment') {
                        fallbackRule.start = parseInt(document.getElementById('fallback-auto-inc-start').value);
                        fallbackRule.step = parseInt(document.getElementById('fallback-auto-inc-step').value);
                    }
                    newRule.on_null = fallbackRule;
                }
                mappingRules[pgTable][pgCol] = newRule;
            }
            updateColumnUIs();
            closeMappingPanelModal();
        }

        function openSettingsModal(tableName) {
            const modal = document.getElementById('settings-modal');
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('visible'), 10);
            const content = document.getElementById('settings-modal-content');
            const tableFilters = migrationFilters[tableName] || {};
            const tableSort = tableFilters.sort || {};
            let colOptions = '<option value="">-- No Sorting --</option>';
            mysqlSchemaData[tableName].columns.forEach(col => {
                colOptions += `<option value="${col.name}" ${tableSort.column === col.name ? 'selected' : ''}>${col.name}</option>`;
            });

            let html = `<h2 class="text-2xl font-bold mb-4">Settings for ${tableName}</h2>`;
            html += `<div class="mb-4 border-b pb-4">
                        <h3 class="font-semibold mb-2">Data Merging (for multi-table sources)</h3>
                        <p class="text-sm text-gray-600 mb-2">If mapping from multiple source tables to one target, specify the column used to link rows from this table to others (e.g., 'id', 'user_id').</p>
                        <input type="text" id="merge-key-input" class="w-full p-2 border border-gray-300 rounded-md" placeholder="e.g., id" value="${escapeHtml(tableFilters.merge_key || 'id')}">
                    </div>`;
            html += `<div class="mb-4 border-b pb-4">
                        <h3 class="font-semibold mb-2">Sort Source Data</h3>
                        <p class="text-sm text-gray-600 mb-2">Sort data before processing. Note: This is only applied when this is the only source table for a mapping.</p>
                        <div class="flex space-x-2">
                            <select id="sort-column-select" class="w-2/3 p-2 border border-gray-300 rounded-md">${colOptions}</select>
                            <select id="sort-order-select" class="w-1/3 p-2 border border-gray-300 rounded-md">
                                <option value="ASC" ${tableSort.order === 'ASC' ? 'selected' : ''}>Ascending</option>
                                <option value="DESC" ${tableSort.order === 'DESC' ? 'selected' : ''}>Descending</option>
                            </select>
                        </div>
                    </div>`;
            html += `<div class="mb-6">
                        <h3 class="font-semibold mb-2">WHERE Clause (Filter Rows)</h3>
                        <div id="filter-rules-container" class="space-y-3"></div>
                        <button type="button" onclick="addFilterRule('${tableName}')" class="text-sm text-blue-600 hover:underline mt-2">+ Add Filter Condition</button>
                     </div>`;
            html += `<div class="mb-4"><h3 class="font-semibold mb-2">Value Replacements</h3><div class="space-y-3">`;
            mysqlSchemaData[tableName].columns.forEach(col => {
                html += `<div class="p-2 border-t border-gray-200"><p class="font-medium">${col.name}</p><div id="replacements-for-${col.name}" class="space-y-2 mt-2"></div>`;
                html += `<button type="button" onclick="addReplacementRule('${tableName}', '${col.name}')" class="text-sm text-blue-600 hover:underline mt-2">+ Add Replacement</button></div>`;
            });
            html += `</div></div>`;
            html += `<div class="flex justify-end space-x-4 mt-6"><button type="button" onclick="closeSettingsModal()" class="btn btn-tertiary">Cancel</button><button type="button" onclick="saveSettings('${tableName}')" class="btn btn-primary">Save Settings</button></div>`;
            
            content.innerHTML = html;
            
            renderFilterRules(tableName);

            if (tableFilters.replacements) {
                for (const colName in tableFilters.replacements) {
                    tableFilters.replacements[colName].forEach(rule => addReplacementRule(tableName, colName, rule.find, rule.replace));
                }
            }
        }
        
        function renderFilterRules(tableName) {
            const container = document.getElementById('filter-rules-container');
            container.innerHTML = '';
            const rules = migrationFilters[tableName]?.where || [];
            if (rules.length === 0) {
                addFilterRule(tableName); // Add one empty rule if none exist
            } else {
                rules.forEach(rule => addFilterRule(tableName, rule));
            }
        }

        function addFilterRule(tableName, rule = {}) {
            const container = document.getElementById('filter-rules-container');
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'flex items-center space-x-2';
            
            const colOptions = mysqlSchemaData[tableName].columns.map(c => `<option value="${c.name}" ${rule.column === c.name ? 'selected' : ''}>${c.name}</option>`).join('');
            const opOptions = ['=', '!=', 'LIKE', 'NOT LIKE', 'REGEXP', 'NOT REGEXP'].map(op => `<option value="${op}" ${rule.op === op ? 'selected' : ''}>${op}</option>`).join('');

            ruleDiv.innerHTML = `
                <select class="w-1/3 p-1 border border-gray-300 rounded-md text-sm filter-column">${colOptions}</select>
                <select class="w-1/4 p-1 border border-gray-300 rounded-md text-sm filter-op">${opOptions}</select>
                <input type="text" class="flex-grow p-1 border border-gray-300 rounded-md text-sm filter-value" placeholder="Value or Pattern" value="${escapeHtml(rule.value || '')}">
                <button type="button" onclick="this.parentElement.remove()" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
            `;
            container.appendChild(ruleDiv);
        }

        function addReplacementRule(tableName, colName, findVal = '', replaceVal = '') {
            const container = document.getElementById(`replacements-for-${colName}`);
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'flex items-center space-x-2';
            ruleDiv.innerHTML = `
                <input type="text" class="w-1/2 p-1 border border-gray-300 rounded-md text-sm find-input" placeholder="Find this value" value="${escapeHtml(findVal)}">
                <span class="font-bold text-gray-500"></span>
                <input type="text" class="w-1/2 p-1 border border-gray-300 rounded-md text-sm replace-input" placeholder="Replace with this" value="${escapeHtml(replaceVal)}">
                <button type="button" onclick="this.parentElement.remove()" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
            `;
            container.appendChild(ruleDiv);
        }

        function saveSettings(tableName) {
            if (!migrationFilters[tableName]) {
                migrationFilters[tableName] = {};
            }
            migrationFilters[tableName].merge_key = document.getElementById('merge-key-input').value || 'id';

            const sortColumn = document.getElementById('sort-column-select').value;
            if (sortColumn) {
                migrationFilters[tableName].sort = {
                    column: sortColumn,
                    order: document.getElementById('sort-order-select').value
                };
            } else {
                delete migrationFilters[tableName].sort;
            }
            
            const whereRules = [];
            document.querySelectorAll('#filter-rules-container > div').forEach(ruleDiv => {
                const column = ruleDiv.querySelector('.filter-column').value;
                const op = ruleDiv.querySelector('.filter-op').value;
                const value = ruleDiv.querySelector('.filter-value').value;
                if (column && op && value) {
                    whereRules.push({ column, op, value });
                }
            });
            migrationFilters[tableName].where = whereRules;

            const replacements = {};
            mysqlSchemaData[tableName].columns.forEach(col => {
                const container = document.getElementById(`replacements-for-${col.name}`);
                const rules = [];
                container.querySelectorAll('.flex').forEach(ruleDiv => {
                    const find = ruleDiv.querySelector('.find-input').value;
                    const replace = ruleDiv.querySelector('.replace-input').value;
                    if (find) {
                        rules.push({ find, replace });
                    }
                });
                if (rules.length > 0) {
                    replacements[col.name] = rules;
                }
            });
            migrationFilters[tableName].replacements = replacements;
            closeSettingsModal();
        }

        async function viewColumnData(tableName, columnName) {
            const modal = document.getElementById('data-preview-modal');
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('visible'), 10);
            const content = document.getElementById('data-preview-content');
            content.innerHTML = `<h2 class="text-2xl font-bold mb-4">Previewing ${tableName}.${columnName}</h2><p>Loading data...</p>`;
            
            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let payload = {};
            if (selector.value === 'custom') {
                payload = { path: customPathInput.value, tableName, columnName };
            } else if (selector.value) {
                payload = { filename: selector.value, tableName, columnName };
            } else {
                alert("Please select a SQL file first.");
                closeDataPreviewModal();
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/get_column_data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to fetch column data.');
                
                let listHtml = `<p class="text-sm text-gray-600 mb-2">Showing ${data.unique_values.length} unique values (out of ${data.total_rows} total rows).</p>`;
                listHtml += '<ul class="data-preview-list border rounded-md p-2 bg-gray-50">';
                if (data.unique_values.length === 0) {
                    listHtml += '<li class="p-1 text-gray-500">No data found for this column.</li>';
                } else {
                    data.unique_values.forEach(val => {
                        listHtml += `<li class="p-1 border-b">${escapeHtml(val) || '<em>NULL or Empty</em>'}</li>`;
                    });
                }
                listHtml += '</ul>';
                
                content.innerHTML = `
                    <div class="flex justify-between items-start">
                        <h2 class="text-2xl font-bold mb-4">Previewing ${tableName}.${columnName}</h2>
                        <button type="button" onclick="closeDataPreviewModal()" class="text-2xl font-bold">&times;</button>
                    </div>
                    ${listHtml}
                `;
            } catch (error) {
                content.innerHTML = `<p class="text-red-500">Error: ${error.message}</p> <button type="button" onclick="closeDataPreviewModal()" class="mt-4 px-4 py-2 bg-gray-200 rounded-md">Close</button>`;
            }
        }

        async function viewSourceTable(tableName) {
            const modal = document.getElementById('data-preview-modal');
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.add('visible'), 10);
            const content = document.getElementById('data-preview-content');
            content.innerHTML = `<h2 class="text-2xl font-bold mb-4">Viewing Full Data for ${tableName}</h2><p>Loading data...</p>`;

            const selector = document.getElementById('sqlFileSelector');
            const customPathInput = document.getElementById('sqlFilePathInput');
            let payload = {};
            if (selector.value === 'custom') {
                payload = { path: customPathInput.value, tableName };
            } else if (selector.value) {
                payload = { filename: selector.value, tableName };
            } else {
                alert("Please select a SQL file first.");
                closeDataPreviewModal();
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/get_source_table_data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to fetch table data.');

                let tableHtml = `<div class="data-preview-list"><table class="data-preview-table"><thead><tr>`;
                data.headers.forEach(header => {
                    tableHtml += `<th>${escapeHtml(header)}</th>`;
                });
                tableHtml += `</tr></thead><tbody>`;
                data.rows.forEach(row => {
                    tableHtml += `<tr>`;
                    data.headers.forEach(header => {
                        tableHtml += `<td>${escapeHtml(row[header])}</td>`;
                    });
                    tableHtml += `</tr>`;
                });
                tableHtml += `</tbody></table></div>`;

                content.innerHTML = `
                    <div class="flex justify-between items-start">
                        <h2 class="text-2xl font-bold mb-4">Full Data for ${tableName}</h2>
                        <button type="button" onclick="closeDataPreviewModal()" class="text-2xl font-bold">&times;</button>
                    </div>
                    ${tableHtml}
                `;
            } catch (error) {
                 content.innerHTML = `<p class="text-red-500">Error: ${error.message}</p> <button type="button" onclick="closeDataPreviewModal()" class="mt-4 px-4 py-2 bg-gray-200 rounded-md">Close</button>`;
            }
        }

        // --- Functions for Saving/Loading Mappings ---

        async function loadSavedMappings() {
            const selector = document.getElementById('savedMappingsSelector');
            try {
                const response = await fetch(`${API_BASE_URL}/api/get_mappings`);
                if (!response.ok) throw new Error('Failed to fetch mappings.');
                const mappings = await response.json();
                selector.innerHTML = '<option value="">-- Select a saved mapping --</option>';
                mappings.forEach(name => {
                    selector.innerHTML += `<option value="${name}">${name}</option>`;
                });
            } catch (error) {
                selector.innerHTML = '<option value="">-- Could not load mappings --</option>';
                handleFetchError(error, 'loading saved mappings');
            }
        }

        async function saveCurrentMapping() {
            const nameInput = document.getElementById('newMappingNameInput');
            const mappingName = nameInput.value.trim();
            if (!mappingName) {
                alert('Please enter a name for the mapping.');
                return;
            }
            if (Object.keys(mappingRules).length === 0) {
                alert('There are no mapping rules to save.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/save_mapping`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: mappingName, config: mappingRules })
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Failed to save mapping.');
                showStatus(result.message, false);
                nameInput.value = ''; // Clear input on success
                loadSavedMappings(); // Refresh the list
            } catch (error) {
                handleFetchError(error, 'saving mapping');
            }
        }

        async function loadSelectedMapping() {
            const selector = document.getElementById('savedMappingsSelector');
            const mappingName = selector.value;
            if (!mappingName) {
                alert('Please select a mapping to load.');
                return;
            }
            if (!mysqlSchemaData || Object.keys(mysqlSchemaData).length === 0 || !postgresSchemaData || Object.keys(postgresSchemaData).length === 0) {
                alert('Please load both source and target schemas before loading a mapping.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/load_mapping/${mappingName}`);
                const loadedRules = await response.json();
                if (!response.ok) throw new Error(loadedRules.error || 'Failed to load mapping.');

                mappingRules = loadedRules;
                
                const sourceTablesToDisplay = new Set();
                const targetTablesToDisplay = new Set();
                for (const pgTable in mappingRules) {
                    targetTablesToDisplay.add(pgTable);
                    for (const pgCol in mappingRules[pgTable]) {
                        const rule = mappingRules[pgTable][pgCol];
                        if (rule.source_table) {
                            sourceTablesToDisplay.add(rule.source_table);
                        }
                        if (rule.lookup_source_table) {
                             sourceTablesToDisplay.add(rule.lookup_source_table);
                        }
                    }
                }

                document.querySelectorAll('#mysql-table-filter input[type="checkbox"]').forEach(cb => {
                    cb.checked = sourceTablesToDisplay.has(cb.value);
                });
                document.querySelectorAll('#pg-table-filter input[type="checkbox"]').forEach(cb => {
                    cb.checked = targetTablesToDisplay.has(cb.value);
                });
                
                updateSourceTableVisibility();
                updateTargetTableVisibility();
                
                setTimeout(() => {
                    updateColumnUIs();
                    showStatus(`Mapping '${mappingName}' loaded successfully.`, false);
                }, 100);

            } catch (error) {
                handleFetchError(error, 'loading selected mapping');
            }
        }
        
        function closeSettingsModal() {
            const modal = document.getElementById('settings-modal');
            modal.classList.remove('visible');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }
        function closeMappingPanelModal() {
            const modal = document.getElementById('mapping-panel-modal');
            modal.classList.remove('visible');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }
        function closeDataPreviewModal() {
            const modal = document.getElementById('data-preview-modal');
            modal.classList.remove('visible');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        // --- AI Assistant Logic ---
        let chatHistory = [];

        function getToolContext() {
            return `
You are an expert AI assistant for a MySQL to PostgreSQL database migration tool.
Your goal is to help users understand and use this tool effectively.
Current Date and Time: ${new Date().toString()}

This tool has a Python Flask backend (app.py) and an HTML/JS frontend.

**TOOL OVERVIEW**
The user selects a MySQL .sql dump file and connects to a target PostgreSQL database. They then map source tables/columns to target tables/columns and run the migration.

**BACKEND (app.py) CAPABILITIES:**
The backend has several key functions:
- \`_get_schema_from_sql_file\`: Parses a .sql file to find all 'CREATE TABLE' and 'INSERT' statements to understand the source database structure.
- \`_parse_mysql_insert\`: A robust function that can parse complex MySQL 'INSERT' statements, including those with messy data (like embedded HTML), and statements that omit the column list.
- \`_perform_migration\`: The main migration engine. It takes the user's mapping configuration and transforms/moves the data.
- API Endpoints (e.g., /api/parse_sql_file, /api/get_tables, /api/run_migration): These are how the frontend communicates with the backend to perform actions.

**FRONTEND CAPABILITIES:**
The user interacts with a multi-step interface:
1.  **Select SQL File**: User picks a .sql file from the server. The backend's \`_get_schema_from_sql_file\` is called to parse it.
2.  **Connect to PostgreSQL**: User provides PG connection details to fetch a list of databases and then tables.
3.  **Map Data**: This is the core step.
    -   Users can drag-and-drop source columns to target columns for a 'direct' mapping.
    -   Clicking a target column opens a detailed mapping panel with advanced options:
        -   **Transformation**: Create new values, e.g., by concatenating multiple source columns.
        -   **Lookup**: Fetch a value from another table (source or target) based on a matching key.
        -   **Static Value**: Hardcode a specific value for a column.
        -   **Auto-Increment**: Create a sequence of numbers.
    -   **Post-Processing**: After a value is determined, it can be further processed (e.g., casting to integer, reformatting a date).
    -   **Fallback**: Define a default value to use if the primary mapping rule results in NULL.
4.  **Run Migration**: User can choose to truncate target tables first and then execute the migration.
5.  **Ask AI on Error**: If a row fails to migrate, an "Ask AI" button appears. This gives you, the AI, the exact error, query, and data to provide a precise solution.

**YOUR TASK:**
Answer user questions clearly and concisely. Refer to the functions and steps above. If a user has a problem, guide them on how to use the tool's features to solve it. For example, if they need to combine a first name and last name, tell them to use a 'Transformation' mapping with the 'CONCAT' function. Be helpful and specific.
`;
        }

        function getErrorAnalysisPrompt(errorDetails) {
            return `
You are a database expert specializing in MySQL to PostgreSQL migrations. A user has encountered an error while using a migration tool. Your task is to analyze the error and provide a clear, actionable solution.

**CONTEXT:**
- The user is migrating data from a MySQL dump file to a PostgreSQL database.
- The tool failed to insert a row and has provided the following details.

**ERROR DETAILS:**
- **PostgreSQL Error Message:** ${errorDetails.error}
- **Failed Query:** ${errorDetails.query}
- **Data Values for the Failed Row:** ${JSON.stringify(errorDetails.values)}

**YOUR TASK:**
1.  **Explain the Cause:** In simple terms, what is the most likely reason for this error? Look for data type mismatches, constraint violations, or syntax issues between MySQL and PostgreSQL.
2.  **Propose a Solution:** Based on the error, recommend a specific fix using the migration tool's features. Be very specific. For example:
    - "The error indicates a data type mismatch. The solution is to use the 'Post-Processing' feature to cast the problematic column to the correct type."
    - "This looks like a date format issue. You should use the 'Re-format Date' option in the 'Post-Processing' section."
3.  **Provide Step-by-Step Instructions:** Give the user a clear, numbered list of steps to follow in the tool to apply your recommended solution. For example:
    1. In the mapping interface, find the target column that is causing the error.
    2. Click on it to open the mapping panel.
    3. In the 'Post-Processing' section, find the 'Change Data Type (Cast)' dropdown.
    4. Select the appropriate data type (e.g., 'Integer') from the list.
    5. Click 'Save Mapping' and try running the migration again.

Be direct, helpful, and focus on solving the user's problem with the tool's built-in capabilities.
`;
        }
        
        function askAiAboutError(errorDetails) {
            const modalOverlay = document.getElementById('ai-chat-modal-overlay');
            modalOverlay.classList.remove('hidden');
            setTimeout(() => modalOverlay.classList.add('visible'), 10);
            
            const prompt = getErrorAnalysisPrompt(errorDetails);
            sendChatMessage(prompt, "Tell me about this error...");
        }

        async function sendChatMessage(prompt = null, userDisplayMessage = null) {
            const input = document.getElementById('ai-chat-input');
            const history = document.getElementById('ai-chat-history');
            const userText = userDisplayMessage || input.value.trim();

            if (!userText) return;

            // Display user message
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'chat-message user-message';
            userMessageDiv.textContent = userText;
            history.appendChild(userMessageDiv);

            input.value = '';
            history.scrollTop = history.scrollHeight;

            // Prepare for AI response
            const aiMessageDiv = document.createElement('div');
            aiMessageDiv.className = 'chat-message ai-message';
            aiMessageDiv.innerHTML = 'Thinking...';
            history.appendChild(aiMessageDiv);
            history.scrollTop = history.scrollHeight;

            const fullPrompt = prompt || (getToolContext() + "\n\n---\n\nUser Question: " + userText);
            
            try {
                const apiKey = "AIzaSyAVlRPQs2bwMTRw7oDOBC4cDDFmP7zIZkM";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const requestPayload = {
                    contents: [{
                        role: "user",
                        parts: [{ text: fullPrompt }]
                    }]
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload)
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const aiText = result.candidates[0].content.parts[0].text;
                    aiMessageDiv.innerHTML = markdownToHtml(aiText);
                } else {
                    aiMessageDiv.textContent = "Sorry, I couldn't get a response. The API might have returned an empty result.";
                }

            } catch (error) {
                console.error("AI Assistant Error:", error);
                aiMessageDiv.textContent = "Sorry, I encountered an error. Please check the console for details.";
            }

            history.scrollTop = history.scrollHeight;
        }
        
        function markdownToHtml(md) {
            // Basic Markdown to HTML conversion
            let html = escapeHtml(md);
            
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

            // Bold
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Italic
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Lists (simple implementation)
            html = html.replace(/^\* (.*$)/gim, '<ul><li>$1</li></ul>');
            html = html.replace(/<\/ul>\n<br><ul>/g, ''); // Merge consecutive list items

            // Code blocks
            html = html.replace(/```(.*?)```/gs, (match, p1) => `<pre><code>${escapeHtml(p1.trim())}</code></pre>`);
            
            // Inline code
            html = html.replace(/`(.*?)`/g, '<code>$1</code>');

            // Newlines
            html = html.replace(/\n/g, '<br>');

            return html;
        }

    </script>
</body>
</html>
